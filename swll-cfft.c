// Wile -- the extremely stable scheming genius compiler
// Copyright 2023, Uwe Hollerbach <uhollerbach@gmail.com>
// License: LGPLv3 or later, see file 'LICENSE-LGPL' for details

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <complex.h>
#include <math.h>
#include <float.h>
#include <sys/types.h>
#include <unistd.h>

#include "wile.h"
#include "alloc.h"
#include "lib-macros.h"

static bool cfft_init = false;

// add new prime here
static lisp_cmplx_t cfft_w3f[3*2], cfft_w3b[3*2],
		    cfft_w5f[5*4], cfft_w5b[5*4],
		    cfft_w7f[7*6], cfft_w7b[7*6],
		    cfft_w11f[11*10], cfft_w11b[11*10];

static const lisp_real_t cfft_pi = PI_L;

static void cfft_init_n(int n, lisp_cmplx_t* wf, lisp_cmplx_t* wb)
{
    int i, j;

    wf[0] = CMPLX(REAL_LIT(1.0), REAL_LIT(0.0));
    for (i = 1; i < n; ++i) {
	wf[i] = CEXP(-2*i*cfft_pi*I/n);
    }
    for (i = 2; i < n; ++i) {
	for (j = 0; j < n; ++j) {
	    wf[n*(i - 1)+j] = wf[(j*i)%n];
	}
    }
    for (i = 0; i < n*(n-1); ++i) {
	wb[i] = CONJ(wf[i]);
    }
}

static void cfft_b2(size_t n, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[2];

    for (i = 0; i < n; i += 2) {
	ai[0] = vs[i] + vs[i+1];
	ai[1] = vs[i] - vs[i+1];
	vs[i]   = ai[0];
	vs[i+1] = ai[1];
    }
}

static void cfft_b4(size_t n, int si, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[4], ci;

    ci = (si > 0) ? I : -I;
    for (i = 0; i < n; i += 4) {
	ai[0] = vs[i] + vs[i+2];
	ai[1] = vs[i] - vs[i+2];
	ai[2] = vs[i+1] + vs[i+3];
	ai[3] = ci*(vs[i+1] - vs[i+3]);

	vs[i]   = ai[0] + ai[2];
	vs[i+1] = ai[1] + ai[3];
	vs[i+2] = ai[0] - ai[2];
	vs[i+3] = ai[1] - ai[3];
    }
}

// b3 .. b11 and m3 .. m11 routines are auto-generated by gen-cfft-code.scm

static void cfft_b3(size_t n, lisp_cmplx_t* ws, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[3];
    for (i = 0; i < n; i += 3) {
	ai[0] = vs[i] + vs[i+1] + vs[i+2];
	ai[1] = vs[i] + ws[1]*vs[i+1] + ws[2]*vs[i+2];
	ai[2] = vs[i] + ws[4]*vs[i+1] + ws[5]*vs[i+2];
	vs[i] = ai[0];
	vs[i+1] = ai[1];
	vs[i+2] = ai[2];
    }
}

static void cfft_m3(size_t n, size_t nc, lisp_cmplx_t* ws,
		    lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k[3], ns;

    ns = nc/3;
    for (i = 0; i < n; i += nc) {
	for (j = 0; j < 3; ++j) {
	    k[j] = i + j*ns;
	}
	for (j = 0; j < ns; ++j) {
	    a2[k[0]+j] = a1[k[0]+j] + a1[k[1]+j] + a1[k[2]+j];
	    a2[k[1]+j] = a1[k[0]+j] + ws[1]*a1[k[1]+j] + ws[2]*a1[k[2]+j];
	    a2[k[2]+j] = a1[k[0]+j] + ws[4]*a1[k[1]+j] + ws[5]*a1[k[2]+j];
	}
    }
}

static void cfft_b5(size_t n, lisp_cmplx_t* ws, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[5];
    for (i = 0; i < n; i += 5) {
	ai[0] = vs[i] + vs[i+1] + vs[i+2] + vs[i+3] + vs[i+4];
	ai[1] = vs[i] + ws[1]*vs[i+1] + ws[2]*vs[i+2] + ws[3]*vs[i+3] + ws[4]*vs[i+4];
	ai[2] = vs[i] + ws[6]*vs[i+1] + ws[7]*vs[i+2] + ws[8]*vs[i+3] + ws[9]*vs[i+4];
	ai[3] = vs[i] + ws[11]*vs[i+1] + ws[12]*vs[i+2] + ws[13]*vs[i+3] + ws[14]*vs[i+4];
	ai[4] = vs[i] + ws[16]*vs[i+1] + ws[17]*vs[i+2] + ws[18]*vs[i+3] + ws[19]*vs[i+4];
	vs[i] = ai[0];
	vs[i+1] = ai[1];
	vs[i+2] = ai[2];
	vs[i+3] = ai[3];
	vs[i+4] = ai[4];
    }
}

static void cfft_m5(size_t n, size_t nc, lisp_cmplx_t* ws,
		    lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k[5], ns;

    ns = nc/5;
    for (i = 0; i < n; i += nc) {
	for (j = 0; j < 5; ++j) {
	    k[j] = i + j*ns;
	}
	for (j = 0; j < ns; ++j) {
	    a2[k[0]+j] = a1[k[0]+j] + a1[k[1]+j] + a1[k[2]+j] + a1[k[3]+j] + a1[k[4]+j];
	    a2[k[1]+j] = a1[k[0]+j] + ws[1]*a1[k[1]+j] + ws[2]*a1[k[2]+j] + ws[3]*a1[k[3]+j] + ws[4]*a1[k[4]+j];
	    a2[k[2]+j] = a1[k[0]+j] + ws[6]*a1[k[1]+j] + ws[7]*a1[k[2]+j] + ws[8]*a1[k[3]+j] + ws[9]*a1[k[4]+j];
	    a2[k[3]+j] = a1[k[0]+j] + ws[11]*a1[k[1]+j] + ws[12]*a1[k[2]+j] + ws[13]*a1[k[3]+j] + ws[14]*a1[k[4]+j];
	    a2[k[4]+j] = a1[k[0]+j] + ws[16]*a1[k[1]+j] + ws[17]*a1[k[2]+j] + ws[18]*a1[k[3]+j] + ws[19]*a1[k[4]+j];
	}
    }
}

static void cfft_b7(size_t n, lisp_cmplx_t* ws, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[7];
    for (i = 0; i < n; i += 7) {
	ai[0] = vs[i] + vs[i+1] + vs[i+2] + vs[i+3] + vs[i+4] + vs[i+5] + vs[i+6];
	ai[1] = vs[i] + ws[1]*vs[i+1] + ws[2]*vs[i+2] + ws[3]*vs[i+3] + ws[4]*vs[i+4] + ws[5]*vs[i+5] + ws[6]*vs[i+6];
	ai[2] = vs[i] + ws[8]*vs[i+1] + ws[9]*vs[i+2] + ws[10]*vs[i+3] + ws[11]*vs[i+4] + ws[12]*vs[i+5] + ws[13]*vs[i+6];
	ai[3] = vs[i] + ws[15]*vs[i+1] + ws[16]*vs[i+2] + ws[17]*vs[i+3] + ws[18]*vs[i+4] + ws[19]*vs[i+5] + ws[20]*vs[i+6];
	ai[4] = vs[i] + ws[22]*vs[i+1] + ws[23]*vs[i+2] + ws[24]*vs[i+3] + ws[25]*vs[i+4] + ws[26]*vs[i+5] + ws[27]*vs[i+6];
	ai[5] = vs[i] + ws[29]*vs[i+1] + ws[30]*vs[i+2] + ws[31]*vs[i+3] + ws[32]*vs[i+4] + ws[33]*vs[i+5] + ws[34]*vs[i+6];
	ai[6] = vs[i] + ws[36]*vs[i+1] + ws[37]*vs[i+2] + ws[38]*vs[i+3] + ws[39]*vs[i+4] + ws[40]*vs[i+5] + ws[41]*vs[i+6];
	vs[i] = ai[0];
	vs[i+1] = ai[1];
	vs[i+2] = ai[2];
	vs[i+3] = ai[3];
	vs[i+4] = ai[4];
	vs[i+5] = ai[5];
	vs[i+6] = ai[6];
    }
}

static void cfft_m7(size_t n, size_t nc, lisp_cmplx_t* ws,
		    lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k[7], ns;

    ns = nc/7;
    for (i = 0; i < n; i += nc) {
	for (j = 0; j < 7; ++j) {
	    k[j] = i + j*ns;
	}
	for (j = 0; j < ns; ++j) {
	    a2[k[0]+j] = a1[k[0]+j] + a1[k[1]+j] + a1[k[2]+j] + a1[k[3]+j] + a1[k[4]+j] + a1[k[5]+j] + a1[k[6]+j];
	    a2[k[1]+j] = a1[k[0]+j] + ws[1]*a1[k[1]+j] + ws[2]*a1[k[2]+j] + ws[3]*a1[k[3]+j] + ws[4]*a1[k[4]+j] + ws[5]*a1[k[5]+j] + ws[6]*a1[k[6]+j];
	    a2[k[2]+j] = a1[k[0]+j] + ws[8]*a1[k[1]+j] + ws[9]*a1[k[2]+j] + ws[10]*a1[k[3]+j] + ws[11]*a1[k[4]+j] + ws[12]*a1[k[5]+j] + ws[13]*a1[k[6]+j];
	    a2[k[3]+j] = a1[k[0]+j] + ws[15]*a1[k[1]+j] + ws[16]*a1[k[2]+j] + ws[17]*a1[k[3]+j] + ws[18]*a1[k[4]+j] + ws[19]*a1[k[5]+j] + ws[20]*a1[k[6]+j];
	    a2[k[4]+j] = a1[k[0]+j] + ws[22]*a1[k[1]+j] + ws[23]*a1[k[2]+j] + ws[24]*a1[k[3]+j] + ws[25]*a1[k[4]+j] + ws[26]*a1[k[5]+j] + ws[27]*a1[k[6]+j];
	    a2[k[5]+j] = a1[k[0]+j] + ws[29]*a1[k[1]+j] + ws[30]*a1[k[2]+j] + ws[31]*a1[k[3]+j] + ws[32]*a1[k[4]+j] + ws[33]*a1[k[5]+j] + ws[34]*a1[k[6]+j];
	    a2[k[6]+j] = a1[k[0]+j] + ws[36]*a1[k[1]+j] + ws[37]*a1[k[2]+j] + ws[38]*a1[k[3]+j] + ws[39]*a1[k[4]+j] + ws[40]*a1[k[5]+j] + ws[41]*a1[k[6]+j];
	}
    }
}

static void cfft_b11(size_t n, lisp_cmplx_t* ws, lisp_cmplx_t* vs)
{
    size_t i;
    lisp_cmplx_t ai[11];
    for (i = 0; i < n; i += 11) {
	ai[0] = vs[i] + vs[i+1] + vs[i+2] + vs[i+3] + vs[i+4] + vs[i+5] + vs[i+6] + vs[i+7] + vs[i+8] + vs[i+9] + vs[i+10];
	ai[1] = vs[i] + ws[1]*vs[i+1] + ws[2]*vs[i+2] + ws[3]*vs[i+3] + ws[4]*vs[i+4] + ws[5]*vs[i+5] + ws[6]*vs[i+6] + ws[7]*vs[i+7] + ws[8]*vs[i+8] + ws[9]*vs[i+9] + ws[10]*vs[i+10];
	ai[2] = vs[i] + ws[12]*vs[i+1] + ws[13]*vs[i+2] + ws[14]*vs[i+3] + ws[15]*vs[i+4] + ws[16]*vs[i+5] + ws[17]*vs[i+6] + ws[18]*vs[i+7] + ws[19]*vs[i+8] + ws[20]*vs[i+9] + ws[21]*vs[i+10];
	ai[3] = vs[i] + ws[23]*vs[i+1] + ws[24]*vs[i+2] + ws[25]*vs[i+3] + ws[26]*vs[i+4] + ws[27]*vs[i+5] + ws[28]*vs[i+6] + ws[29]*vs[i+7] + ws[30]*vs[i+8] + ws[31]*vs[i+9] + ws[32]*vs[i+10];
	ai[4] = vs[i] + ws[34]*vs[i+1] + ws[35]*vs[i+2] + ws[36]*vs[i+3] + ws[37]*vs[i+4] + ws[38]*vs[i+5] + ws[39]*vs[i+6] + ws[40]*vs[i+7] + ws[41]*vs[i+8] + ws[42]*vs[i+9] + ws[43]*vs[i+10];
	ai[5] = vs[i] + ws[45]*vs[i+1] + ws[46]*vs[i+2] + ws[47]*vs[i+3] + ws[48]*vs[i+4] + ws[49]*vs[i+5] + ws[50]*vs[i+6] + ws[51]*vs[i+7] + ws[52]*vs[i+8] + ws[53]*vs[i+9] + ws[54]*vs[i+10];
	ai[6] = vs[i] + ws[56]*vs[i+1] + ws[57]*vs[i+2] + ws[58]*vs[i+3] + ws[59]*vs[i+4] + ws[60]*vs[i+5] + ws[61]*vs[i+6] + ws[62]*vs[i+7] + ws[63]*vs[i+8] + ws[64]*vs[i+9] + ws[65]*vs[i+10];
	ai[7] = vs[i] + ws[67]*vs[i+1] + ws[68]*vs[i+2] + ws[69]*vs[i+3] + ws[70]*vs[i+4] + ws[71]*vs[i+5] + ws[72]*vs[i+6] + ws[73]*vs[i+7] + ws[74]*vs[i+8] + ws[75]*vs[i+9] + ws[76]*vs[i+10];
	ai[8] = vs[i] + ws[78]*vs[i+1] + ws[79]*vs[i+2] + ws[80]*vs[i+3] + ws[81]*vs[i+4] + ws[82]*vs[i+5] + ws[83]*vs[i+6] + ws[84]*vs[i+7] + ws[85]*vs[i+8] + ws[86]*vs[i+9] + ws[87]*vs[i+10];
	ai[9] = vs[i] + ws[89]*vs[i+1] + ws[90]*vs[i+2] + ws[91]*vs[i+3] + ws[92]*vs[i+4] + ws[93]*vs[i+5] + ws[94]*vs[i+6] + ws[95]*vs[i+7] + ws[96]*vs[i+8] + ws[97]*vs[i+9] + ws[98]*vs[i+10];
	ai[10] = vs[i] + ws[100]*vs[i+1] + ws[101]*vs[i+2] + ws[102]*vs[i+3] + ws[103]*vs[i+4] + ws[104]*vs[i+5] + ws[105]*vs[i+6] + ws[106]*vs[i+7] + ws[107]*vs[i+8] + ws[108]*vs[i+9] + ws[109]*vs[i+10];
	vs[i] = ai[0];
	vs[i+1] = ai[1];
	vs[i+2] = ai[2];
	vs[i+3] = ai[3];
	vs[i+4] = ai[4];
	vs[i+5] = ai[5];
	vs[i+6] = ai[6];
	vs[i+7] = ai[7];
	vs[i+8] = ai[8];
	vs[i+9] = ai[9];
	vs[i+10] = ai[10];
    }
}

static void cfft_m11(size_t n, size_t nc, lisp_cmplx_t* ws,
		     lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k[11], ns;

    ns = nc/11;
    for (i = 0; i < n; i += nc) {
	for (j = 0; j < 11; ++j) {
	    k[j] = i + j*ns;
	}
	for (j = 0; j < ns; ++j) {
	    a2[k[0]+j] = a1[k[0]+j] + a1[k[1]+j] + a1[k[2]+j] + a1[k[3]+j] + a1[k[4]+j] + a1[k[5]+j] + a1[k[6]+j] + a1[k[7]+j] + a1[k[8]+j] + a1[k[9]+j] + a1[k[10]+j];
	    a2[k[1]+j] = a1[k[0]+j] + ws[1]*a1[k[1]+j] + ws[2]*a1[k[2]+j] + ws[3]*a1[k[3]+j] + ws[4]*a1[k[4]+j] + ws[5]*a1[k[5]+j] + ws[6]*a1[k[6]+j] + ws[7]*a1[k[7]+j] + ws[8]*a1[k[8]+j] + ws[9]*a1[k[9]+j] + ws[10]*a1[k[10]+j];
	    a2[k[2]+j] = a1[k[0]+j] + ws[12]*a1[k[1]+j] + ws[13]*a1[k[2]+j] + ws[14]*a1[k[3]+j] + ws[15]*a1[k[4]+j] + ws[16]*a1[k[5]+j] + ws[17]*a1[k[6]+j] + ws[18]*a1[k[7]+j] + ws[19]*a1[k[8]+j] + ws[20]*a1[k[9]+j] + ws[21]*a1[k[10]+j];
	    a2[k[3]+j] = a1[k[0]+j] + ws[23]*a1[k[1]+j] + ws[24]*a1[k[2]+j] + ws[25]*a1[k[3]+j] + ws[26]*a1[k[4]+j] + ws[27]*a1[k[5]+j] + ws[28]*a1[k[6]+j] + ws[29]*a1[k[7]+j] + ws[30]*a1[k[8]+j] + ws[31]*a1[k[9]+j] + ws[32]*a1[k[10]+j];
	    a2[k[4]+j] = a1[k[0]+j] + ws[34]*a1[k[1]+j] + ws[35]*a1[k[2]+j] + ws[36]*a1[k[3]+j] + ws[37]*a1[k[4]+j] + ws[38]*a1[k[5]+j] + ws[39]*a1[k[6]+j] + ws[40]*a1[k[7]+j] + ws[41]*a1[k[8]+j] + ws[42]*a1[k[9]+j] + ws[43]*a1[k[10]+j];
	    a2[k[5]+j] = a1[k[0]+j] + ws[45]*a1[k[1]+j] + ws[46]*a1[k[2]+j] + ws[47]*a1[k[3]+j] + ws[48]*a1[k[4]+j] + ws[49]*a1[k[5]+j] + ws[50]*a1[k[6]+j] + ws[51]*a1[k[7]+j] + ws[52]*a1[k[8]+j] + ws[53]*a1[k[9]+j] + ws[54]*a1[k[10]+j];
	    a2[k[6]+j] = a1[k[0]+j] + ws[56]*a1[k[1]+j] + ws[57]*a1[k[2]+j] + ws[58]*a1[k[3]+j] + ws[59]*a1[k[4]+j] + ws[60]*a1[k[5]+j] + ws[61]*a1[k[6]+j] + ws[62]*a1[k[7]+j] + ws[63]*a1[k[8]+j] + ws[64]*a1[k[9]+j] + ws[65]*a1[k[10]+j];
	    a2[k[7]+j] = a1[k[0]+j] + ws[67]*a1[k[1]+j] + ws[68]*a1[k[2]+j] + ws[69]*a1[k[3]+j] + ws[70]*a1[k[4]+j] + ws[71]*a1[k[5]+j] + ws[72]*a1[k[6]+j] + ws[73]*a1[k[7]+j] + ws[74]*a1[k[8]+j] + ws[75]*a1[k[9]+j] + ws[76]*a1[k[10]+j];
	    a2[k[8]+j] = a1[k[0]+j] + ws[78]*a1[k[1]+j] + ws[79]*a1[k[2]+j] + ws[80]*a1[k[3]+j] + ws[81]*a1[k[4]+j] + ws[82]*a1[k[5]+j] + ws[83]*a1[k[6]+j] + ws[84]*a1[k[7]+j] + ws[85]*a1[k[8]+j] + ws[86]*a1[k[9]+j] + ws[87]*a1[k[10]+j];
	    a2[k[9]+j] = a1[k[0]+j] + ws[89]*a1[k[1]+j] + ws[90]*a1[k[2]+j] + ws[91]*a1[k[3]+j] + ws[92]*a1[k[4]+j] + ws[93]*a1[k[5]+j] + ws[94]*a1[k[6]+j] + ws[95]*a1[k[7]+j] + ws[96]*a1[k[8]+j] + ws[97]*a1[k[9]+j] + ws[98]*a1[k[10]+j];
	    a2[k[10]+j] = a1[k[0]+j] + ws[100]*a1[k[1]+j] + ws[101]*a1[k[2]+j] + ws[102]*a1[k[3]+j] + ws[103]*a1[k[4]+j] + ws[104]*a1[k[5]+j] + ws[105]*a1[k[6]+j] + ws[106]*a1[k[7]+j] + ws[107]*a1[k[8]+j] + ws[108]*a1[k[9]+j] + ws[109]*a1[k[10]+j];
	}
    }
}

static void cfft_sep(size_t n, size_t nc, size_t s,
		     lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k, ns;

    ns = nc/s;
    for (k = 0; k < n; k += nc) {
	for (i = 0; i < ns; ++i) {
	    for (j = 0; j < s; ++j) {
		a2[k+i+j*ns] = a1[k+j+i*s];
	    }
	}
    }
}

static void cfft_twid_gen(int si, size_t nc, size_t s, lisp_cmplx_t* ws)
{
    size_t i, j, k, ns;
    lisp_cmplx_t a;

    a = si*2*cfft_pi*I/nc;
    ns = nc/s;
    i = 0;
    for (j = 1; j < s; ++j) {
	for (k = 0; k < ns; ++k) {
	    ws[i++] = CEXP(a*j*k);
	}
    }
}

static void cfft_twid_mul(size_t n, size_t nc, size_t s,
			  lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, ns;

    ns = nc/s;
    for (i = 0; i < n; i += nc) {
	for (j = ns; j < nc; ++j) {
	    a1[i+j] *= a2[j-ns];
	}
    }
}

static void cfft_m4(size_t n, size_t nc, int si,
		    lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    size_t i, j, k[4], ns;
    lisp_cmplx_t ci;

    ci = (si > 0) ? I : -I;
    ns = nc/4;
    for (i = 0; i < n; i += nc) {
	for (j = 0; j < 4; ++j) {
	    k[j] = i + j*ns;
	}
	for (j = 0; j < ns; ++j) {
	    a2[k[0]+j] = a1[k[0]+j] + a1[k[2]+j];
	    a2[k[1]+j] = a1[k[0]+j] - a1[k[2]+j];
	    a2[k[2]+j] = a1[k[1]+j] + a1[k[3]+j];
	    a2[k[3]+j] = ci*(a1[k[1]+j] - a1[k[3]+j]);
	}
	for (j = 0; j < ns; ++j) {
	    a1[k[0]+j] = a2[k[0]+j] + a2[k[2]+j];
	    a1[k[1]+j] = a2[k[1]+j] + a2[k[3]+j];
	    a1[k[2]+j] = a2[k[0]+j] - a2[k[2]+j];
	    a1[k[3]+j] = a2[k[1]+j] - a2[k[3]+j];
	}
    }
}

// add new prime here

#define SETUP_M(d)							\
    do {								\
	cfft_sep(n, nc, d, a1, a2);					\
	ar = swll_cfft(si, n, nc/d, a2, a1);				\
	if (ar == a2) {							\
	    ar = a1;							\
	    a1 = a2;							\
	    a2 = ar;							\
	}								\
	cfft_twid_gen(si, nc, d, a2);					\
	cfft_twid_mul(n, nc, d, a1, a2);				\
    } while (0)

void swll_cfft_init(void)
{
    if (!cfft_init) {
	cfft_init_n(3, cfft_w3f, cfft_w3b);
	cfft_init_n(5, cfft_w5f, cfft_w5b);
	cfft_init_n(7, cfft_w7f, cfft_w7b);
	cfft_init_n(11, cfft_w11f, cfft_w11b);
	// add new prime here
	cfft_init = true;
    }
}

bool swll_cfft_good_n(lisp_int_t n)
{
    if (n <= 0) {
	return false;
    }
    while (n%2 == 0) {
	n /= 2;
    }
    while (n%3 == 0) {
	n /= 3;
    }
    while (n%5 == 0) {
	n /= 5;
    }
    while (n%7 == 0) {
	n /= 7;
    }
    while (n%11 == 0) {
	n /= 11;
    }
// add new prime here
    return (n == 1);
}

lisp_cmplx_t* swll_cfft(int si, size_t n, size_t nc,
			lisp_cmplx_t* a1, lisp_cmplx_t* a2)
{
    lisp_cmplx_t* ar;

    if (nc <= 1) {
	return a1;
    } else if (nc == 4) {
	cfft_b4(n, si, a1);
	return a1;
    } else if (nc%4 == 0) {
	SETUP_M(4);
	cfft_m4(n, nc, si, a1, a2);
	return a1;
    } else if (nc == 2) {
	cfft_b2(n, a1);
	return a1;
    } else if (nc == 3) {
	cfft_b3(n, (si < 0) ? cfft_w3f : cfft_w3b, a1);
	return a1;
    } else if (nc == 5) {
	cfft_b5(n, (si < 0) ? cfft_w5f : cfft_w5b, a1);
	return a1;
    } else if (nc == 7) {
	cfft_b7(n, (si < 0) ? cfft_w7f : cfft_w7b, a1);
	return a1;
    } else if (nc == 11) {
	cfft_b11(n, (si < 0) ? cfft_w11f : cfft_w11b, a1);
	return a1;
// add new prime here -- bP case
    } else if (nc%11 == 0) {
// add new prime here -- mP case
	SETUP_M(11);
	cfft_m11(n, nc, (si < 0) ? cfft_w11f : cfft_w11b, a1, a2);
	return a2;
    } else if (nc%7 == 0) {
	SETUP_M(7);
	cfft_m7(n, nc, (si < 0) ? cfft_w7f : cfft_w7b, a1, a2);
	return a2;
    } else if (nc%5 == 0) {
	SETUP_M(5);
	cfft_m5(n, nc, (si < 0) ? cfft_w5f : cfft_w5b, a1, a2);
	return a2;
    } else if (nc%3 == 0) {
	SETUP_M(3);
	cfft_m3(n, nc, (si < 0) ? cfft_w3f : cfft_w3b, a1, a2);
	return a2;
    } else if (nc%2 == 0) {
	// because b2, b4, and m4 are defined, this never gets hit
	FATAL("cfft", "internal error m2");
    } else {
	FATAL("cfft", "internal error ??");
    }

    return a2;
}

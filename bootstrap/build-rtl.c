// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

lval var_argv;
lval var_cmd_name;
lval var_stdin;
lval var_stdout;
lval var_stderr;
lval var_pi;
lval var_euler_gamma;
lval var_show_sign;
lval var_int_base;
lval var_flt_base;
lval var_flt_precision;

struct wile_profile_t* wile_profile;
int wile_profile_size;

static lval fn_1(lptr*, lptr);	// (ERR . strs)
static lval fn_2(lptr*, lptr);	// (read-all-lines port)
static lval fn_3(lptr*, lptr);	// (run-cmd str . strs)
static lval fn_4(lptr*, lptr);	// (compile-single file dflag)
static lval fn_5(lptr*, lptr);	// (take-section cut-pattern lines)
static lval fn_6(lptr*, lptr);	// (compile-split file bld-dir dflag)
static lval fn_21(lptr*, lptr);
static lval fn_84(lptr*, lptr);
static lval fn_162(lptr*, lptr);
static lval fn_191(lptr*, lptr);
static lval fn_198(lptr*, lptr);
static lval fn_293(lptr*, lptr);
static lval fn_378(lptr*, lptr);

// definitions

// write-string
static lval fn_10(lptr* var_11, lptr var_12)
{
lval var_14;
var_14 = var_12[0];
{
lval vs[6];
vs[0] = var_14;
var_14 = wile_write_string(NULL, vs);
}
return var_14;
}
// end of prim fn_10

// (ERR . strs)
static lval fn_1(lptr* var_7, lptr var_8)
{
lval var_15;
{
lval vs[3];
vs[0] = LVI_PROC(fn_10,NULL,-1);
vs[1] = var_stderr;
vs[2] = var_8[0];
var_15 = gen_list(3, vs, NULL);
}
var_15 = wile_apply_function(&(var_15), __FILE__, __LINE__);
lval var_16;
var_16 = LVI_INT(1);
lval var_17;
exit(var_16.v.iv);
return var_17;
}
// end of function fn_1

// lambda (acc)
static lval fn_21(lptr* var_22, lptr var_23)
{
lbl_24:;
lval var_25;
lval var_26;
{
lval vs[6];
vs[0] = (*(var_22[0]));
var_26 = wile_read_line(NULL, vs);
}
var_25 = var_26;
lval var_27;
if (LV_IS_FALSE(var_25)) {
lval var_28;
{
lval vs[6];
vs[0] = var_23[0];
var_28 = wile_list_reverse(NULL, vs);
}
var_27 = var_28;
} else {
lval var_29;
{
lptr p1 = NULL, p2 = NULL;
if (var_25.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_25;
}
if (var_23[0].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_23[0];
}
var_29 = LVI_PAIR(p1, p2);
}
lval var_32[6];
var_32[0] = var_29;
var_23[0] = var_32[0];
goto lbl_24;	// selfie
}
return var_27;
}
// end of lambda fn_21

// (read-all-lines port)
static lval fn_2(lptr* var_18, lptr var_19)
{
lptr var_22[1];
var_22[0] = &(var_19[0]);
lval var_33;
var_33 = LVI_NIL();
lval var_34;
lval var_35[6];
var_35[0] = var_33;
var_34 = fn_21(var_22, var_35);
return var_34;
}
// end of function fn_2

// string-append
static lval fn_41(lptr* var_42, lptr var_43)
{
lval var_45;
var_45 = var_43[0];
{
lval vs[6];
vs[0] = var_45;
var_45 = wile_string_append(NULL, vs);
}
return var_45;
}
// end of prim fn_41

// (run-cmd str . strs)
static lval fn_3(lptr* var_37, lptr var_38)
{
lval var_40;
lval var_46;
var_46 = LVI_STRING(" ");
lval var_47;
{
lval vs[4];
vs[0] = LVI_PROC(fn_41,NULL,-1);
vs[1] = var_38[0];
vs[2] = var_46;
vs[3] = var_38[1];
var_47 = gen_list(4, vs, NULL);
}
var_47 = wile_apply_function(&(var_47), __FILE__, __LINE__);
var_40 = var_47;
lval var_48;
lval var_49;
var_49 = run_system_command(var_40, __FILE__, __LINE__);
var_48 = var_49;
lval var_50;
lval var_51;
switch (var_48.vt) {
case LV_REAL:
var_51 = LVI_BOOL(var_48.v.rv == 0.0);
break;
case LV_RAT:
var_51 = LVI_BOOL((var_48.v.irv.num == 0 && var_48.v.irv.den != 0));
break;
case LV_INT:
var_51 = LVI_BOOL(var_48.v.iv == 0);
break;
case LV_CMPLX:
var_51 = LVI_BOOL(CREAL(var_48.v.cv) == 0.0 && CIMAG(var_48.v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
if (LV_IS_FALSE(var_51)) {
lval var_52;
var_52 = LVI_STRING("command \'%s\' failed with status %d\n");
lval var_53;
{
lval vs[2];
vs[0] = var_40;
vs[1] = var_48;
var_53 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_stderr;
vs[1] = var_52;
vs[2] = var_53;
var_53 = wile_fprintf(NULL, vs);
}
lval var_54;
var_54 = LVI_INT(1);
lval var_55;
exit(var_54.v.iv);
var_50 = var_55;
} else {
lval var_56;
var_56 = LVI_BOOL(false);
var_50 = var_56;
}
return var_50;
}
// end of function fn_3

// (compile-single file dflag)
static lval fn_4(lptr* var_57, lptr var_58)
{
lval var_60;
lval var_61;
var_61 = LVI_CHAR(46);
lval var_62;
if (var_58[0].vt != LV_STRING || var_61.vt != LV_CHAR) {
WILE_EX("string-find-last-char", "expects a string and a character input");
}
{
char* pos = strrchr(var_58[0].v.str, var_61.v.chr);
if (pos) {
var_62 = LVI_INT(pos - var_58[0].v.str);
} else {
var_62 = LVI_BOOL(false);
}
}
var_60 = var_62;
lval var_63;
lval var_64;
if (LV_IS_FALSE(var_60)) {
var_64 = var_58[0];
} else {
lval var_65;
var_65 = LVI_INT(0);
lval var_66;
if (var_58[0].vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_58[0].v.str);
if (var_65.v.iv < 0 || (size_t) var_65.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
if (var_60.v.iv < var_65.v.iv || (size_t) var_60.v.iv >= len) {
WILE_EX("string-copy", "end index is out of range");
}
var_66.vt = LV_STRING;
var_66.v.str = LISP_ALLOC(char, 1 + var_60.v.iv - var_65.v.iv);
LISP_ASSERT(var_66.v.str != NULL);
memcpy(var_66.v.str, var_58[0].v.str + var_65.v.iv, var_60.v.iv - var_65.v.iv);
var_66.v.str[var_60.v.iv - var_65.v.iv] = '\0';
}
var_64 = var_66;
}
var_63 = var_64;
if (LV_IS_FALSE(var_60)) {
(void)
 LVI_STRING("");
} else {
if (var_58[0].vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_58[0].v.str);
if (var_60.v.iv < 0 || (size_t) var_60.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
(void)
 LVI_STRING(var_58[0].v.str + var_60.v.iv);
}
}
lval var_71;
var_71 = LVI_STRING("wile -o -v");
lval var_72;
if (LV_IS_FALSE(var_58[1])) {
lval var_73;
var_73 = LVI_STRING("");
var_72 = var_73;
} else {
lval var_74;
var_74 = LVI_STRING("-g ");
var_72 = var_74;
}
lval var_76[6];
var_76[0] = var_71;
lval var_78[6];
var_78[0] = var_72;
var_78[1] = var_58[0];
var_76[1] = gen_list(2, var_78, NULL);
(void)
 fn_3(NULL, var_76);
lval var_79;
var_79 = LVI_STRING(".o");
lval var_80;
{
lval vs[2];
vs[0] = var_63;
vs[1] = var_79;
var_80 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_80;
var_80 = wile_string_append(NULL, vs);
}
return var_80;
}
// end of function fn_4

// lambda (ls acc)
static lval fn_84(lptr* var_85, lptr var_86)
{
lbl_87:;
lval var_88;
do {
lval var_89;
var_89 = LVI_BOOL(var_86[0].vt == LV_NIL);
if (!LV_IS_FALSE(var_89)) {
lval var_90;
{
lval vs[6];
vs[0] = var_86[1];
var_90 = wile_list_reverse(NULL, vs);
}
lval var_91;
var_91 = LVI_NIL();
lval var_92;
{
lval vs[2];
vs[0] = var_90;
vs[1] = var_91;
var_92 = gen_list(2, vs, NULL);
}
var_88 = var_92;
break;
}
lval var_93;
if (var_86[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_93 = (var_86[0].v.pair.car ? *(var_86[0].v.pair.car) : LVI_NIL());
lval var_94;
{
lval vs[6];
vs[0] = (*(var_85[0]));
vs[1] = var_93;
var_94 = wile_regex_match(NULL, vs);
}
if (!LV_IS_FALSE(var_94)) {
lval var_95;
{
lval vs[6];
vs[0] = var_86[1];
var_95 = wile_list_reverse(NULL, vs);
}
lval var_96;
if (var_86[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_96 = (var_86[0].v.pair.cdr ? *(var_86[0].v.pair.cdr) : LVI_NIL());
lval var_97;
{
lval vs[2];
vs[0] = var_95;
vs[1] = var_96;
var_97 = gen_list(2, vs, NULL);
}
var_88 = var_97;
break;
}
lval var_98;
if (var_86[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_98 = (var_86[0].v.pair.cdr ? *(var_86[0].v.pair.cdr) : LVI_NIL());
lval var_99;
if (var_86[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_99 = (var_86[0].v.pair.car ? *(var_86[0].v.pair.car) : LVI_NIL());
lval var_100;
{
lptr p1 = NULL, p2 = NULL;
if (var_99.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_99;
}
if (var_86[1].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_86[1];
}
var_100 = LVI_PAIR(p1, p2);
}
lval var_103[6];
var_103[0] = var_98;
var_103[1] = var_100;
var_86[0] = var_103[0];
var_86[1] = var_103[1];
goto lbl_87;	// selfie
} while (0);
return var_88;
}
// end of lambda fn_84

// (take-section cut-pattern lines)
static lval fn_5(lptr* var_81, lptr var_82)
{
lptr var_85[1];
var_85[0] = &(var_82[0]);
lval var_104;
var_104 = LVI_NIL();
lval var_105;
lval var_106[6];
var_106[0] = var_82[1];
var_106[1] = var_104;
var_105 = fn_84(var_85, var_106);
return var_105;
}
// end of function fn_5

// lambda (l)
static lval fn_191(lptr* var_192, lptr var_193)
{
lval var_195;
var_195 = LVI_CHAR(10);
lval var_196;
{
lval vs[3];
vs[0] = (*(var_192[0]));
vs[1] = var_193[0];
vs[2] = var_195;
var_196 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_196;
var_196 = wile_write_string(NULL, vs);
}
return var_196;
}
// end of lambda fn_191

// lambda (l)
static lval fn_198(lptr* var_199, lptr var_200)
{
lval var_202;
var_202 = LVI_CHAR(10);
lval var_203;
{
lval vs[3];
vs[0] = (*(var_199[0]));
vs[1] = var_200[0];
vs[2] = var_202;
var_203 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_203;
var_203 = wile_write_string(NULL, vs);
}
return var_203;
}
// end of lambda fn_198

// lambda (ls ix)
static lval fn_162(lptr* var_163, lptr var_164)
{
lbl_165:;
lval var_166;
lval var_167;
var_167 = LVI_BOOL(var_164[0].vt == LV_NIL);
if (LV_IS_FALSE(var_167)) {
lval var_168;
lval var_169;
var_169 = num2string(var_164[1], 10, INT_MIN, __FILE__, __LINE__);
lval var_170;
var_170 = LVI_CHAR(48);
lval var_171;
var_171 = LVI_INT(6);
lval var_172;
{
lval vs[6];
vs[0] = var_169;
vs[1] = var_170;
vs[2] = var_171;
var_172 = wile_string_pad_left(NULL, vs);
}
var_168 = var_172;
lval var_173;
lval var_174;
var_174 = LVI_STRING("/");
lval var_175;
var_175 = LVI_STRING("-");
lval var_176;
{
lval vs[5];
vs[0] = (*(var_163[0]));
vs[1] = var_174;
vs[2] = (*(var_163[1]));
vs[3] = var_175;
vs[4] = var_168;
var_176 = gen_list(5, vs, NULL);
}
{
lval vs[6];
vs[0] = var_176;
var_176 = wile_string_append(NULL, vs);
}
var_173 = var_176;
lval var_177;
lval var_178;
{
lval vs[2];
vs[0] = var_173;
vs[1] = (*(var_163[2]));
var_178 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_178;
var_178 = wile_string_append(NULL, vs);
}
var_177 = var_178;
lval var_179;
lval var_180;
var_180 = LVI_STRING("w");
lval var_181;
{
FILE* fp = fopen(var_177.v.str, var_180.v.str);
if (fp) {
var_181 = LVI_FPORT(fp);
} else {
var_181 = LVI_BOOL(false);
}
}
var_179 = var_181;
lval var_182;
lval var_183;
lval var_184[6];
var_184[0] = (*(var_163[3]));
var_184[1] = var_164[0];
var_183 = fn_5(NULL, var_184);
var_182 = var_183;
lval var_186;
lval var_187;
if (var_182.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_187 = (var_182.v.pair.car ? *(var_182.v.pair.car) : LVI_NIL());
var_186 = var_187;
lval var_188;
var_188 = LVI_STRING("writing ");
lval var_189;
var_189 = LVI_CHAR(10);
lval var_190;
{
lval vs[3];
vs[0] = var_188;
vs[1] = var_177;
vs[2] = var_189;
var_190 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_190;
var_190 = wile_write_string(NULL, vs);
}
lptr var_192[1];
var_192[0] = &(var_179);
lval var_197;
var_197 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_191,var_192,1);
vs[1] = (*(var_163[4]));
vs[2] = var_197;
var_197 = wile_for_each(NULL, vs);
}
lptr var_199[1];
var_199[0] = &(var_179);
lval var_204;
var_204 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_198,var_199,1);
vs[1] = var_186;
vs[2] = var_204;
var_204 = wile_for_each(NULL, vs);
}
{
lval vs[6];
vs[0] = var_179;
(void)
 wile_flushport(NULL, vs);
}
{
lval vs[6];
vs[0] = var_179;
(void)
 wile_closeport(NULL, vs);
}
lval var_208;
var_208 = LVI_STRING(".scm");
lval var_209;
var_209 = LVI_BOOL(strcmp((*(var_163[2])).v.str, var_208.v.str) == 0);
if (LV_IS_FALSE(var_209)) {
(void)
 LVI_BOOL(false);
} else {
lval var_211;
var_211 = LVI_STRING("wile -v -c ");
lval var_212;
if (LV_IS_FALSE((*(var_163[5])))) {
lval var_213;
var_213 = LVI_STRING("");
var_212 = var_213;
} else {
lval var_214;
var_214 = LVI_STRING("-g");
var_212 = var_214;
}
lval var_215;
var_215 = LVI_STRING(" ");
lval var_216;
var_216 = LVI_STRING(".scm ");
lval var_217;
var_217 = LVI_STRING(".c");
lval var_219[6];
var_219[0] = var_211;
lval var_221[6];
var_221[0] = var_212;
var_221[1] = var_215;
var_221[2] = var_173;
var_221[3] = var_216;
var_221[4] = var_173;
var_221[5] = var_217;
var_219[1] = gen_list(6, var_221, NULL);
(void)
 fn_3(NULL, var_219);
}
lval var_222;
var_222 = LVI_STRING("rm -f");
lval var_223;
var_223 = LVI_STRING("/*.h");
lval var_225[6];
var_225[0] = var_222;
lval var_227[6];
var_227[0] = (*(var_163[0]));
var_227[1] = var_223;
var_225[1] = gen_list(2, var_227, NULL);
(void)
 fn_3(NULL, var_225);
lval var_228;
var_228 = LVI_STRING("wile -v -o ");
lval var_229;
if (LV_IS_FALSE((*(var_163[5])))) {
lval var_230;
var_230 = LVI_STRING("");
var_229 = var_230;
} else {
lval var_231;
var_231 = LVI_STRING("-g");
var_229 = var_231;
}
lval var_232;
var_232 = LVI_STRING(" ");
lval var_233;
var_233 = LVI_STRING(".c ");
lval var_234;
var_234 = LVI_STRING(".o");
lval var_236[6];
var_236[0] = var_228;
lval var_238[6];
var_238[0] = var_229;
var_238[1] = var_232;
var_238[2] = var_173;
var_238[3] = var_233;
var_238[4] = var_173;
var_238[5] = var_234;
var_236[1] = gen_list(6, var_238, NULL);
(void)
 fn_3(NULL, var_236);
lval var_239;
var_239 = LVI_STRING("cadr");
lval var_240;
{
char* cp = strchr(var_239.v.str, 'r');
var_240 = var_182;
while (*(--cp) != 'c') {
if (var_240.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_240 = (var_240.v.pair.car ? *(var_240.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_240 = (var_240.v.pair.cdr ? *(var_240.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_239.v.str);
}
}
}
lval var_241;
var_241 = LVI_INT(1);
lval var_242;
{
lval vs[2];
vs[0] = var_164[1];
vs[1] = var_241;
var_242 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_242;
var_242 = wile_add(NULL, vs);
}
lval var_245[6];
var_245[0] = var_240;
var_245[1] = var_242;
var_164[0] = var_245[0];
var_164[1] = var_245[1];
goto lbl_165;	// selfie
} else {
lval var_246;
var_246 = LVI_STRING("all done!\n");
lval var_247;
{
lval vs[1];
vs[0] = var_246;
var_247 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_247;
var_247 = wile_write_string(NULL, vs);
}
var_166 = var_247;
}
return var_166;
}
// end of lambda fn_162

// (compile-split file bld-dir dflag)
static lval fn_6(lptr* var_108, lptr var_109)
{
lval var_111;
lval var_112;
var_112 = LVI_STRING("r");
lval var_113;
{
FILE* fp = fopen(var_109[0].v.str, var_112.v.str);
if (fp) {
var_113 = LVI_FPORT(fp);
} else {
var_113 = LVI_BOOL(false);
}
}
var_111 = var_113;
lval var_114;
lval var_115;
lval var_116[6];
var_116[0] = var_111;
var_115 = fn_2(NULL, var_116);
var_114 = var_115;
lval var_118;
lval var_119;
var_119 = LVI_CHAR(46);
lval var_120;
if (var_109[0].vt != LV_STRING || var_119.vt != LV_CHAR) {
WILE_EX("string-find-last-char", "expects a string and a character input");
}
{
char* pos = strrchr(var_109[0].v.str, var_119.v.chr);
if (pos) {
var_120 = LVI_INT(pos - var_109[0].v.str);
} else {
var_120 = LVI_BOOL(false);
}
}
var_118 = var_120;
lval var_121;
lval var_122;
if (LV_IS_FALSE(var_118)) {
var_122 = var_109[0];
} else {
lval var_123;
var_123 = LVI_INT(0);
lval var_124;
if (var_109[0].vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_109[0].v.str);
if (var_123.v.iv < 0 || (size_t) var_123.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
if (var_118.v.iv < var_123.v.iv || (size_t) var_118.v.iv >= len) {
WILE_EX("string-copy", "end index is out of range");
}
var_124.vt = LV_STRING;
var_124.v.str = LISP_ALLOC(char, 1 + var_118.v.iv - var_123.v.iv);
LISP_ASSERT(var_124.v.str != NULL);
memcpy(var_124.v.str, var_109[0].v.str + var_123.v.iv, var_118.v.iv - var_123.v.iv);
var_124.v.str[var_118.v.iv - var_123.v.iv] = '\0';
}
var_122 = var_124;
}
var_121 = var_122;
lval var_125;
lval var_126;
if (LV_IS_FALSE(var_118)) {
lval var_127;
var_127 = LVI_STRING("");
var_126 = var_127;
} else {
lval var_128;
if (var_109[0].vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_109[0].v.str);
if (var_118.v.iv < 0 || (size_t) var_118.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
var_128 = LVI_STRING(var_109[0].v.str + var_118.v.iv);
}
var_126 = var_128;
}
var_125 = var_126;
lval var_129;
lval var_130;
var_130 = LVI_STRING("(--8><--)+$");
var_129 = var_130;
lval var_131;
lval var_132;
lval var_133[6];
var_133[0] = var_129;
var_133[1] = var_114;
var_132 = fn_5(NULL, var_133);
var_131 = var_132;
lval var_135;
lval var_136;
if (var_131.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_136 = (var_131.v.pair.car ? *(var_131.v.pair.car) : LVI_NIL());
var_135 = var_136;
lval var_137;
lval var_138;
var_138 = LVI_STRING("cadr");
lval var_139;
{
char* cp = strchr(var_138.v.str, 'r');
var_139 = var_131;
while (*(--cp) != 'c') {
if (var_139.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_139 = (var_139.v.pair.car ? *(var_139.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_139 = (var_139.v.pair.cdr ? *(var_139.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_138.v.str);
}
}
}
var_137 = var_139;
(void)
 LVI_INT(0);
{
lval vs[6];
vs[0] = var_111;
(void)
 wile_closeport(NULL, vs);
}
lval var_144;
var_144 = LVI_BOOL(var_137.vt == LV_NIL);
if (LV_IS_FALSE(var_144)) {
(void)
 LVI_BOOL(false);
} else {
lval var_146;
var_146 = LVI_STRING("there is no split directive!\n");
lval var_147;
{
lval vs[1];
vs[0] = var_146;
var_147 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_147;
var_147 = wile_write_string(NULL, vs);
}
lval var_148;
var_148 = LVI_INT(1);
exit(var_148.v.iv);
}
lval var_151;
var_151 = LVI_BOOL(false);
do {
lval var_152;
var_152 = LVI_STRING(".scm");
lval var_153;
var_153 = LVI_BOOL(strcmp(var_125.v.str, var_152.v.str) == 0);
var_151 = var_153;
if (!LV_IS_FALSE(var_151)) { break; }
lval var_154;
var_154 = LVI_STRING(".c");
lval var_155;
var_155 = LVI_BOOL(strcmp(var_125.v.str, var_154.v.str) == 0);
var_151 = var_155;
if (!LV_IS_FALSE(var_151)) { break; }
} while (0);
if (LV_IS_FALSE(var_151)) {
lval var_156;
var_156 = LVI_STRING("error: don\'t know how to handle ");
lval var_157;
var_157 = LVI_STRING(" files yet!\n");
lval var_158;
{
lval vs[3];
vs[0] = var_156;
vs[1] = var_125;
vs[2] = var_157;
var_158 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_158;
var_158 = wile_write_string(NULL, vs);
}
lval var_159;
var_159 = LVI_INT(1);
exit(var_159.v.iv);
} else {
(void)
 LVI_BOOL(false);
}
lptr var_163[6];
var_163[5] = &(var_109[2]);
var_163[4] = &(var_135);
var_163[3] = &(var_129);
var_163[2] = &(var_125);
var_163[1] = &(var_121);
var_163[0] = &(var_109[1]);
lval var_248;
var_248 = LVI_INT(0);
lval var_249;
lval var_250[6];
var_250[0] = var_137;
var_250[1] = var_248;
var_249 = fn_162(var_163, var_250);
return var_249;
}
// end of function fn_6

// lambda (fs acc)
static lval fn_293(lptr* var_294, lptr var_295)
{
lbl_296:;
lval var_297;
do {
lval var_298;
var_298 = LVI_BOOL(var_295[0].vt == LV_NIL);
if (!LV_IS_FALSE(var_298)) {
lval var_299;
{
lval vs[6];
vs[0] = var_295[1];
var_299 = wile_list_reverse(NULL, vs);
}
var_297 = var_299;
break;
}
lval var_300;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_300 = (var_295[0].v.pair.car ? *(var_295[0].v.pair.car) : LVI_NIL());
lval var_301;
var_301 = LVI_STRING("-s");
lval var_302;
var_302 = LVI_BOOL(strcmp(var_300.v.str, var_301.v.str) == 0);
if (!LV_IS_FALSE(var_302)) {
lval var_304;
var_304 = LVI_BOOL(mkdir((*(var_294[0])).v.str, 0755) == 0);
if (LV_IS_FALSE(var_304)) {
lval var_305;
var_305 = LVI_STRING("error: create-directory \'");
lval var_306;
var_306 = LVI_STRING("\' failed:\n");
lval var_307;
var_307 = LVI_INT(errno);
lval var_308;
var_308 = LVI_STRING(strerror(var_307.v.iv));
lval var_309;
var_309 = LVI_CHAR(10);
lval var_311[6];
lval var_313[6];
var_313[0] = var_305;
var_313[1] = (*(var_294[0]));
var_313[2] = var_306;
var_313[3] = var_308;
var_313[4] = var_309;
var_311[0] = gen_list(5, var_313, NULL);
(void)
 fn_1(NULL, var_311);
} else {
(void)
 LVI_BOOL(false);
}
lval var_315;
var_315 = LVI_BOOL(true);
(*(var_294[1])) = var_315;
lval var_316;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_316 = (var_295[0].v.pair.cdr ? *(var_295[0].v.pair.cdr) : LVI_NIL());
lval var_319[6];
var_319[0] = var_316;
var_319[1] = var_295[1];
var_295[0] = var_319[0];
var_295[1] = var_319[1];
goto lbl_296;	// selfie
}
lval var_320;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_320 = (var_295[0].v.pair.car ? *(var_295[0].v.pair.car) : LVI_NIL());
lval var_321;
var_321 = LVI_STRING("-k");
lval var_322;
var_322 = LVI_BOOL(strcmp(var_320.v.str, var_321.v.str) == 0);
if (!LV_IS_FALSE(var_322)) {
lval var_323;
var_323 = LVI_BOOL(false);
(*(var_294[2])) = var_323;
lval var_324;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_324 = (var_295[0].v.pair.cdr ? *(var_295[0].v.pair.cdr) : LVI_NIL());
lval var_327[6];
var_327[0] = var_324;
var_327[1] = var_295[1];
var_295[0] = var_327[0];
var_295[1] = var_327[1];
goto lbl_296;	// selfie
}
if (!LV_IS_FALSE((*(var_294[1])))) {
lval var_328;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_328 = (var_295[0].v.pair.car ? *(var_295[0].v.pair.car) : LVI_NIL());
lval var_330[6];
var_330[0] = var_328;
var_330[1] = (*(var_294[0]));
var_330[2] = (*(var_294[3]));
(void)
 fn_6(NULL, var_330);
lval var_332;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_332 = (var_295[0].v.pair.cdr ? *(var_295[0].v.pair.cdr) : LVI_NIL());
lval var_335[6];
var_335[0] = var_332;
var_335[1] = var_295[1];
var_295[0] = var_335[0];
var_295[1] = var_335[1];
goto lbl_296;	// selfie
}
lval var_336;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_336 = (var_295[0].v.pair.cdr ? *(var_295[0].v.pair.cdr) : LVI_NIL());
lval var_337;
if (var_295[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_337 = (var_295[0].v.pair.car ? *(var_295[0].v.pair.car) : LVI_NIL());
lval var_338;
lval var_339[6];
var_339[0] = var_337;
var_339[1] = (*(var_294[3]));
var_338 = fn_4(NULL, var_339);
lval var_341;
{
lptr p1 = NULL, p2 = NULL;
if (var_338.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_338;
}
if (var_295[1].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_295[1];
}
var_341 = LVI_PAIR(p1, p2);
}
lval var_344[6];
var_344[0] = var_336;
var_344[1] = var_341;
var_295[0] = var_344[0];
var_295[1] = var_344[1];
goto lbl_296;	// selfie
} while (0);
return var_297;
}
// end of lambda fn_293

// string-join-by
static lval fn_350(lptr* var_351, lptr var_352)
{
lval var_354;
var_354 = var_352[1];
{
lval vs[6];
vs[0] = var_352[0];
vs[1] = var_354;
var_354 = wile_string_join_by(NULL, vs);
}
return var_354;
}
// end of prim fn_350

// lambda (f)
static lval fn_378(lptr* var_379, lptr var_380)
{
lval var_382;
var_382 = LVI_STRING("remove-file \'");
lval var_383;
var_383 = LVI_STRING("\' ");
lval var_384;
lval var_385;
var_385 = LVI_BOOL(unlink(var_380[0].v.str) == 0);
if (LV_IS_FALSE(var_385)) {
lval var_386;
var_386 = LVI_STRING("fail");
var_384 = var_386;
} else {
lval var_387;
var_387 = LVI_STRING("ok");
var_384 = var_387;
}
lval var_388;
var_388 = LVI_STRING("!\n");
lval var_389;
{
lval vs[5];
vs[0] = var_382;
vs[1] = var_380[0];
vs[2] = var_383;
vs[3] = var_384;
vs[4] = var_388;
var_389 = gen_list(5, vs, NULL);
}
{
lval vs[6];
vs[0] = var_389;
var_389 = wile_write_string(NULL, vs);
}
return var_389;
}
// end of lambda fn_378

const int global_tc_min_args = 6;

lval scheme_main(int argc, char** argv)
{
wile_profile = NULL;
wile_profile_size = 0;
WILE_CONFIG_SYM4();
if (argc <= 1) {
var_argv = LVI_NIL();
} else {
int i;
lval* sas = LISP_ALLOC(lval, argc-1);
LISP_ASSERT(sas != NULL);
for (i = 1; i < argc; ++i) {
sas[i-1] = LVI_STRING(argv[i]);
}
var_argv = gen_list(argc - 1, sas, NULL);
}
var_cmd_name = LVI_STRING(argv[0]);
var_stdin = LVI_FPORT(stdin);
var_stdout = LVI_FPORT(stdout);
var_stderr = LVI_FPORT(stderr);
var_pi = LVI_REAL(3.14159265358979323846264338327950280e+00Q);
var_euler_gamma = LVI_REAL(5.77215664901532860606512090082402471e-01Q);
var_show_sign = LVI_BOOL(false);
var_int_base = LVI_INT(10);
var_flt_base = LVI_INT(10);
var_flt_precision = LVI_INT(-15);
lval var_252;
lval var_253;
var_253 = LVI_BOOL(false);
var_252 = var_253;
lval var_254;
lval var_255;
var_255 = LVI_BOOL(false);
var_254 = var_255;
lval var_256;
lval var_257;
var_257 = LVI_BOOL(true);
var_256 = var_257;
lval var_258;
lval var_259;
var_259 = LVI_STRING("bld-rtl-dir");
var_258 = var_259;
lval var_260;
lval var_261;
var_261 = LVI_BOOL(false);
var_260 = var_261;
lval var_262;
lval var_263;
var_263 = LVI_BOOL(false);
var_262 = var_263;
lval var_265;
var_265 = LVI_BOOL(true);
do {
lval var_266;
var_266 = LVI_BOOL(var_argv.vt == LV_NIL);
lval var_267;
var_267 = LVI_BOOL(LV_IS_FALSE(var_266));
var_265 = var_267;
if (LV_IS_FALSE(var_265)) { break; }
lval var_268;
if (var_argv.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_268 = (var_argv.v.pair.car ? *(var_argv.v.pair.car) : LVI_NIL());
lval var_269;
var_269 = LVI_STRING("-g");
lval var_270;
var_270 = LVI_BOOL(strcmp(var_268.v.str, var_269.v.str) == 0);
var_265 = var_270;
if (LV_IS_FALSE(var_265)) { break; }
} while (0);
if (LV_IS_FALSE(var_265)) {
(void)
 LVI_BOOL(false);
} else {
lval var_272;
var_272 = LVI_BOOL(true);
var_252 = var_272;
lval var_273;
if (var_argv.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_273 = (var_argv.v.pair.cdr ? *(var_argv.v.pair.cdr) : LVI_NIL());
var_argv = var_273;
(void)
 var_argv;
}
lval var_275;
var_275 = LVI_BOOL(var_argv.vt == LV_NIL);
if (LV_IS_FALSE(var_275)) {
(void)
 LVI_BOOL(false);
} else {
lval var_277;
var_277 = LVI_STRING("error: no output archive file specified!\n");
lval var_279[6];
lval var_281[6];
var_281[0] = var_277;
var_279[0] = gen_list(1, var_281, NULL);
(void)
 fn_1(NULL, var_279);
}
lval var_282;
if (var_argv.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_282 = (var_argv.v.pair.car ? *(var_argv.v.pair.car) : LVI_NIL());
var_260 = var_282;
lval var_283;
if (var_argv.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_283 = (var_argv.v.pair.cdr ? *(var_argv.v.pair.cdr) : LVI_NIL());
var_argv = var_283;
lval var_285;
var_285 = LVI_BOOL(access(var_258.v.str, F_OK) == 0);
if (LV_IS_FALSE(var_285)) {
(void)
 LVI_BOOL(false);
} else {
lval var_287;
var_287 = LVI_STRING("error: build directory \'");
lval var_288;
var_288 = LVI_STRING("\' already exists!\n");
lval var_290[6];
lval var_292[6];
var_292[0] = var_287;
var_292[1] = var_258;
var_292[2] = var_288;
var_290[0] = gen_list(3, var_292, NULL);
(void)
 fn_1(NULL, var_290);
}
lptr var_294[4];
var_294[3] = &(var_252);
var_294[2] = &(var_256);
var_294[1] = &(var_254);
var_294[0] = &(var_258);
lval var_345;
var_345 = LVI_NIL();
lval var_346;
lval var_347[6];
var_347[0] = var_argv;
var_347[1] = var_345;
var_346 = fn_293(var_294, var_347);
var_262 = var_346;
lval var_349;
lval var_355;
var_355 = LVI_STRING(" ");
lval var_356;
var_356 = LVI_STRING("ar rcs");
lval var_357;
{
lval vs[5];
vs[0] = LVI_PROC(fn_350,NULL,-2);
vs[1] = var_355;
vs[2] = var_356;
vs[3] = var_260;
vs[4] = var_262;
var_357 = gen_list(5, vs, NULL);
}
var_357 = wile_apply_function(&(var_357), __FILE__, __LINE__);
var_349 = var_357;
if (LV_IS_FALSE(var_254)) {
(void)
 LVI_BOOL(false);
} else {
lval var_360;
var_360 = LVI_STRING(" ");
lval var_361;
var_361 = LVI_STRING("/*.o");
lval var_362;
{
lval vs[4];
vs[0] = var_349;
vs[1] = var_360;
vs[2] = var_258;
vs[3] = var_361;
var_362 = gen_list(4, vs, NULL);
}
{
lval vs[6];
vs[0] = var_362;
var_362 = wile_string_append(NULL, vs);
}
var_349 = var_362;
}
lval var_363;
lval var_364;
var_364 = run_system_command(var_349, __FILE__, __LINE__);
var_363 = var_364;
lval var_366;
var_366 = LVI_BOOL(true);
do {
lval var_367;
var_367 = LVI_BOOL(var_363.vt == LV_INT);
var_366 = var_367;
if (LV_IS_FALSE(var_366)) { break; }
lval var_368;
switch (var_363.vt) {
case LV_REAL:
var_368 = LVI_BOOL(var_363.v.rv == 0.0);
break;
case LV_RAT:
var_368 = LVI_BOOL((var_363.v.irv.num == 0 && var_363.v.irv.den != 0));
break;
case LV_INT:
var_368 = LVI_BOOL(var_363.v.iv == 0);
break;
case LV_CMPLX:
var_368 = LVI_BOOL(CREAL(var_363.v.cv) == 0.0 && CIMAG(var_363.v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
var_366 = var_368;
if (LV_IS_FALSE(var_366)) { break; }
} while (0);
if (LV_IS_FALSE(var_366)) {
lval var_369;
var_369 = LVI_STRING("archive create failed!\n");
lval var_371[6];
lval var_373[6];
var_373[0] = var_369;
var_371[0] = gen_list(1, var_373, NULL);
(void)
 fn_1(NULL, var_371);
} else {
lval var_374;
var_374 = LVI_STRING("archive created ok\n");
lval var_375;
{
lval vs[1];
vs[0] = var_374;
var_375 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_375;
var_375 = wile_write_string(NULL, vs);
}
}
lval var_376;
if (LV_IS_FALSE(var_256)) {
lval var_377;
var_377 = LVI_BOOL(false);
var_376 = var_377;
} else {
lptr var_379[0];
lval var_390;
var_390 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_378,var_379,1);
vs[1] = var_262;
vs[2] = var_390;
var_390 = wile_for_each(NULL, vs);
}
lval var_391;
lval var_392;
var_392 = LVI_STRING("rm -rf ");
lval var_393;
{
lval vs[2];
vs[0] = var_392;
vs[1] = var_258;
var_393 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_393;
var_393 = wile_string_append(NULL, vs);
}
lval var_394;
var_394 = run_system_command(var_393, __FILE__, __LINE__);
var_391 = var_394;
lval var_395;
lval var_396;
var_396 = LVI_BOOL(true);
do {
lval var_397;
var_397 = LVI_BOOL(var_391.vt == LV_INT);
var_396 = var_397;
if (LV_IS_FALSE(var_396)) { break; }
lval var_398;
switch (var_391.vt) {
case LV_REAL:
var_398 = LVI_BOOL(var_391.v.rv == 0.0);
break;
case LV_RAT:
var_398 = LVI_BOOL((var_391.v.irv.num == 0 && var_391.v.irv.den != 0));
break;
case LV_INT:
var_398 = LVI_BOOL(var_391.v.iv == 0);
break;
case LV_CMPLX:
var_398 = LVI_BOOL(CREAL(var_391.v.cv) == 0.0 && CIMAG(var_391.v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
var_396 = var_398;
if (LV_IS_FALSE(var_396)) { break; }
} while (0);
if (LV_IS_FALSE(var_396)) {
lval var_399;
var_399 = LVI_STRING("build directory cleanup failed!\n");
lval var_400;
lval var_401[6];
lval var_403[6];
var_403[0] = var_399;
var_401[0] = gen_list(1, var_403, NULL);
var_400 = fn_1(NULL, var_401);
var_395 = var_400;
} else {
lval var_404;
var_404 = LVI_STRING("build directory successfully cleaned up\n");
lval var_405;
{
lval vs[1];
vs[0] = var_404;
var_405 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_405;
var_405 = wile_write_string(NULL, vs);
}
var_395 = var_405;
}
var_376 = var_395;
}
return var_376;
}

// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

lval var_argv;
lval var_cmd_name;
lval var_stdin;
lval var_stdout;
lval var_stderr;
lval var_pi;
lval var_euler_gamma;
lval var_show_sign;
lval var_int_base;
lval var_flt_base;
lval var_flt_precision;

struct wile_profile_t* wile_profile;
int wile_profile_size;

static lval fn_1(lptr*, lptr);	// (read-all-lines port)
static lval var_2;		// do-debug
static lval fn_4(lptr*, lptr);	// (take-section cut-pattern lines)
static lval fn_5(lptr*, lptr);	// (run-cmd str . strs)
static lval fn_9(lptr*, lptr);
static lval fn_28(lptr*, lptr);
static lval fn_161(lptr*, lptr);
static lval fn_189(lptr*, lptr);
static lval fn_196(lptr*, lptr);

// definitions

// lambda (acc)
static lval fn_9(lptr* var_10, lptr var_11)
{
lbl_12:;
lval var_13;
lval var_14;
{
lval vs[6];
vs[0] = (*(var_10[0]));
var_14 = wile_read_line(NULL, vs);
}
var_13 = var_14;
lval var_15;
if (LV_IS_FALSE(var_13)) {
lval var_16;
{
lval vs[6];
vs[0] = var_11[0];
var_16 = wile_list_reverse(NULL, vs);
}
var_15 = var_16;
} else {
lval var_17;
{
lptr p1 = NULL, p2 = NULL;
if (var_13.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_13;
}
if (var_11[0].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_11[0];
}
var_17 = LVI_PAIR(p1, p2);
}
lval var_20[6];
var_20[0] = var_17;
var_11[0] = var_20[0];
goto lbl_12;	// selfie
}
return var_15;
}
// end of lambda fn_9

// (read-all-lines port)
static lval fn_1(lptr* var_6, lptr var_7)
{
lptr var_10[1];
var_10[0] = &(var_7[0]);
lval var_21;
var_21 = LVI_NIL();
lval var_22;
lval var_23[6];
var_23[0] = var_21;
var_22 = fn_9(var_10, var_23);
return var_22;
}
// end of function fn_1

// lambda (ls acc)
static lval fn_28(lptr* var_29, lptr var_30)
{
lbl_31:;
lval var_32;
do {
lval var_33;
var_33 = LVI_BOOL(var_30[0].vt == LV_NIL);
if (!LV_IS_FALSE(var_33)) {
lval var_34;
{
lval vs[6];
vs[0] = var_30[1];
var_34 = wile_list_reverse(NULL, vs);
}
lval var_35;
var_35 = LVI_NIL();
lval var_36;
{
lval vs[2];
vs[0] = var_34;
vs[1] = var_35;
var_36 = gen_list(2, vs, NULL);
}
var_32 = var_36;
break;
}
lval var_37;
if (var_30[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_37 = (var_30[0].v.pair.car ? *(var_30[0].v.pair.car) : LVI_NIL());
lval var_38;
{
lval vs[6];
vs[0] = (*(var_29[0]));
vs[1] = var_37;
var_38 = wile_regex_match(NULL, vs);
}
if (!LV_IS_FALSE(var_38)) {
lval var_39;
{
lval vs[6];
vs[0] = var_30[1];
var_39 = wile_list_reverse(NULL, vs);
}
lval var_40;
if (var_30[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_40 = (var_30[0].v.pair.cdr ? *(var_30[0].v.pair.cdr) : LVI_NIL());
lval var_41;
{
lval vs[2];
vs[0] = var_39;
vs[1] = var_40;
var_41 = gen_list(2, vs, NULL);
}
var_32 = var_41;
break;
}
lval var_42;
if (var_30[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_42 = (var_30[0].v.pair.cdr ? *(var_30[0].v.pair.cdr) : LVI_NIL());
lval var_43;
if (var_30[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_43 = (var_30[0].v.pair.car ? *(var_30[0].v.pair.car) : LVI_NIL());
lval var_44;
{
lptr p1 = NULL, p2 = NULL;
if (var_43.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_43;
}
if (var_30[1].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_30[1];
}
var_44 = LVI_PAIR(p1, p2);
}
lval var_47[6];
var_47[0] = var_42;
var_47[1] = var_44;
var_30[0] = var_47[0];
var_30[1] = var_47[1];
goto lbl_31;	// selfie
} while (0);
return var_32;
}
// end of lambda fn_28

// (take-section cut-pattern lines)
static lval fn_4(lptr* var_25, lptr var_26)
{
lptr var_29[1];
var_29[0] = &(var_26[0]);
lval var_48;
var_48 = LVI_NIL();
lval var_49;
lval var_50[6];
var_50[0] = var_26[1];
var_50[1] = var_48;
var_49 = fn_28(var_29, var_50);
return var_49;
}
// end of function fn_4

// string-append
static lval fn_56(lptr* var_57, lptr var_58)
{
lval var_60;
var_60 = var_58[0];
{
lval vs[6];
vs[0] = var_60;
var_60 = wile_string_append(NULL, vs);
}
return var_60;
}
// end of prim fn_56

// (run-cmd str . strs)
static lval fn_5(lptr* var_52, lptr var_53)
{
lval var_55;
lval var_61;
var_61 = LVI_STRING(" ");
lval var_62;
{
lval vs[4];
vs[0] = LVI_PROC(fn_56,NULL,-1);
vs[1] = var_53[0];
vs[2] = var_61;
vs[3] = var_53[1];
var_62 = gen_list(4, vs, NULL);
}
var_62 = wile_apply_function(&(var_62), __FILE__, __LINE__);
var_55 = var_62;
lval var_63;
lval var_64;
var_64 = run_system_command(var_55, __FILE__, __LINE__);
var_63 = var_64;
lval var_66;
switch (var_63.vt) {
case LV_REAL:
var_66 = LVI_BOOL(var_63.v.rv == 0.0);
break;
case LV_RAT:
var_66 = LVI_BOOL((var_63.v.irv.num == 0 && var_63.v.irv.den != 0));
break;
case LV_INT:
var_66 = LVI_BOOL(var_63.v.iv == 0);
break;
case LV_CMPLX:
var_66 = LVI_BOOL(CREAL(var_63.v.cv) == 0.0 && CIMAG(var_63.v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
if (LV_IS_FALSE(var_66)) {
lval var_67;
var_67 = LVI_STRING("command \'%s\' failed with status %d\n");
lval var_68;
{
lval vs[2];
vs[0] = var_55;
vs[1] = var_63;
var_68 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_stderr;
vs[1] = var_67;
vs[2] = var_68;
var_68 = wile_fprintf(NULL, vs);
}
lval var_69;
var_69 = LVI_INT(1);
exit(var_69.v.iv);
} else {
(void)
 LVI_BOOL(false);
}
lval var_72;
var_72 = LVI_BOOL(true);
return var_72;
}
// end of function fn_5

// lambda (l)
static lval fn_189(lptr* var_190, lptr var_191)
{
lval var_193;
var_193 = LVI_CHAR(10);
lval var_194;
{
lval vs[3];
vs[0] = (*(var_190[0]));
vs[1] = var_191[0];
vs[2] = var_193;
var_194 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_194;
var_194 = wile_write_string(NULL, vs);
}
return var_194;
}
// end of lambda fn_189

// lambda (l)
static lval fn_196(lptr* var_197, lptr var_198)
{
lval var_200;
var_200 = LVI_CHAR(10);
lval var_201;
{
lval vs[3];
vs[0] = (*(var_197[0]));
vs[1] = var_198[0];
vs[2] = var_200;
var_201 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_201;
var_201 = wile_write_string(NULL, vs);
}
return var_201;
}
// end of lambda fn_196

// lambda (ls ix)
static lval fn_161(lptr* var_162, lptr var_163)
{
lbl_164:;
lval var_165;
lval var_166;
var_166 = LVI_BOOL(var_163[0].vt == LV_NIL);
if (LV_IS_FALSE(var_166)) {
lval var_167;
lval var_168;
var_168 = num2string(var_163[1], 10, INT_MIN, __FILE__, __LINE__);
lval var_169;
var_169 = LVI_CHAR(48);
lval var_170;
var_170 = LVI_INT(6);
lval var_171;
{
lval vs[6];
vs[0] = var_168;
vs[1] = var_169;
vs[2] = var_170;
var_171 = wile_string_pad_left(NULL, vs);
}
var_167 = var_171;
lval var_172;
lval var_173;
var_173 = LVI_STRING("-");
lval var_174;
{
lval vs[4];
vs[0] = (*(var_162[0]));
vs[1] = (*(var_162[1]));
vs[2] = var_173;
vs[3] = var_167;
var_174 = gen_list(4, vs, NULL);
}
{
lval vs[6];
vs[0] = var_174;
var_174 = wile_string_append(NULL, vs);
}
var_172 = var_174;
lval var_175;
lval var_176;
{
lval vs[2];
vs[0] = var_172;
vs[1] = (*(var_162[2]));
var_176 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_176;
var_176 = wile_string_append(NULL, vs);
}
var_175 = var_176;
lval var_177;
lval var_178;
var_178 = LVI_STRING("w");
lval var_179;
{
FILE* fp = fopen(var_175.v.str, var_178.v.str);
if (fp) {
var_179 = LVI_FPORT(fp);
} else {
var_179 = LVI_BOOL(false);
}
}
var_177 = var_179;
lval var_180;
lval var_181;
lval var_182[6];
var_182[0] = (*(var_162[3]));
var_182[1] = var_163[0];
var_181 = fn_4(NULL, var_182);
var_180 = var_181;
lval var_184;
lval var_185;
if (var_180.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_185 = (var_180.v.pair.car ? *(var_180.v.pair.car) : LVI_NIL());
var_184 = var_185;
lval var_186;
var_186 = LVI_STRING("writing ");
lval var_187;
var_187 = LVI_CHAR(10);
lval var_188;
{
lval vs[3];
vs[0] = var_186;
vs[1] = var_175;
vs[2] = var_187;
var_188 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_188;
var_188 = wile_write_string(NULL, vs);
}
lptr var_190[1];
var_190[0] = &(var_177);
lval var_195;
var_195 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_189,var_190,1);
vs[1] = (*(var_162[4]));
vs[2] = var_195;
var_195 = wile_for_each(NULL, vs);
}
lptr var_197[1];
var_197[0] = &(var_177);
lval var_202;
var_202 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_196,var_197,1);
vs[1] = var_184;
vs[2] = var_202;
var_202 = wile_for_each(NULL, vs);
}
{
lval vs[6];
vs[0] = var_177;
(void)
 wile_flushport(NULL, vs);
}
{
lval vs[6];
vs[0] = var_177;
(void)
 wile_closeport(NULL, vs);
}
lval var_206;
var_206 = LVI_STRING(".scm");
lval var_207;
var_207 = LVI_BOOL(strcmp((*(var_162[2])).v.str, var_206.v.str) == 0);
if (LV_IS_FALSE(var_207)) {
(void)
 LVI_BOOL(false);
} else {
lval var_209;
var_209 = LVI_STRING("wile -v -c ");
lval var_210;
if (LV_IS_FALSE(var_2)) {
lval var_211;
var_211 = LVI_STRING("");
var_210 = var_211;
} else {
lval var_212;
var_212 = LVI_STRING("-g");
var_210 = var_212;
}
lval var_213;
var_213 = LVI_STRING(" ");
lval var_214;
var_214 = LVI_STRING(".scm ");
lval var_215;
var_215 = LVI_STRING(".c");
lval var_217[6];
var_217[0] = var_209;
lval var_219[6];
var_219[0] = var_210;
var_219[1] = var_213;
var_219[2] = var_172;
var_219[3] = var_214;
var_219[4] = var_172;
var_219[5] = var_215;
var_217[1] = gen_list(6, var_219, NULL);
(void)
 fn_5(NULL, var_217);
}
lval var_220;
var_220 = LVI_STRING("rm -f");
lval var_221;
var_221 = LVI_STRING("*.h");
lval var_223[6];
var_223[0] = var_220;
lval var_225[6];
var_225[0] = (*(var_162[0]));
var_225[1] = var_221;
var_223[1] = gen_list(2, var_225, NULL);
(void)
 fn_5(NULL, var_223);
lval var_226;
var_226 = LVI_STRING("wile -v -o ");
lval var_227;
if (LV_IS_FALSE(var_2)) {
lval var_228;
var_228 = LVI_STRING("");
var_227 = var_228;
} else {
lval var_229;
var_229 = LVI_STRING("-g");
var_227 = var_229;
}
lval var_230;
var_230 = LVI_STRING(" ");
lval var_231;
var_231 = LVI_STRING(".c ");
lval var_232;
var_232 = LVI_STRING(".o");
lval var_234[6];
var_234[0] = var_226;
lval var_236[6];
var_236[0] = var_227;
var_236[1] = var_230;
var_236[2] = var_172;
var_236[3] = var_231;
var_236[4] = var_172;
var_236[5] = var_232;
var_234[1] = gen_list(6, var_236, NULL);
(void)
 fn_5(NULL, var_234);
lval var_237;
var_237 = LVI_STRING("cadr");
lval var_238;
{
char* cp = strchr(var_237.v.str, 'r');
var_238 = var_180;
while (*(--cp) != 'c') {
if (var_238.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_238 = (var_238.v.pair.car ? *(var_238.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_238 = (var_238.v.pair.cdr ? *(var_238.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_237.v.str);
}
}
}
lval var_239;
var_239 = LVI_INT(1);
lval var_240;
{
lval vs[2];
vs[0] = var_163[1];
vs[1] = var_239;
var_240 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_240;
var_240 = wile_add(NULL, vs);
}
lval var_243[6];
var_243[0] = var_238;
var_243[1] = var_240;
var_163[0] = var_243[0];
var_163[1] = var_243[1];
goto lbl_164;	// selfie
} else {
lval var_244;
var_244 = LVI_STRING("all done!\n");
lval var_245;
{
lval vs[1];
vs[0] = var_244;
var_245 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_245;
var_245 = wile_write_string(NULL, vs);
}
var_165 = var_245;
}
return var_165;
}
// end of lambda fn_161

const int global_tc_min_args = 6;

lval scheme_main(int argc, char** argv)
{
wile_profile = NULL;
wile_profile_size = 0;
{
uint16_t binfo = wile_binfo();
#ifdef WILE_USES_GC
if (!(binfo & 0x01)) {
fprintf(stderr, "warning: RTL is not configured to use garbage collection\n");
}
#else
if (binfo & 0x01) {
fprintf(stderr, "warning: RTL is configured to use garbage collection\n");
}
#endif
}
if (argc <= 1) {
var_argv = LVI_NIL();
} else {
int i;
lval* sas = LISP_ALLOC(lval, argc-1);
LISP_ASSERT(sas != NULL);
for (i = 1; i < argc; ++i) {
sas[i-1] = LVI_STRING(argv[i]);
}
var_argv = gen_list(argc - 1, sas, NULL);
}
var_cmd_name = LVI_STRING(argv[0]);
var_stdin = LVI_FPORT(stdin);
var_stdout = LVI_FPORT(stdout);
var_stderr = LVI_FPORT(stderr);
var_pi = LVI_REAL(3.14159265358979311599796346854418516e+00Q);
var_euler_gamma = LVI_REAL(5.77215664901532865549427242513047531e-01Q);
var_show_sign = LVI_BOOL(false);
var_int_base = LVI_INT(10);
var_flt_base = LVI_INT(10);
var_flt_precision = LVI_INT(-15);
lval var_3;
var_3 = LVI_BOOL(false);
var_2 = var_3;
lval var_74;
var_74 = LVI_BOOL(true);
do {
lval var_75;
var_75 = LVI_BOOL(var_argv.vt == LV_NIL);
lval var_76;
var_76 = LVI_BOOL(LV_IS_FALSE(var_75));
var_74 = var_76;
if (LV_IS_FALSE(var_74)) { break; }
lval var_77;
if (var_argv.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_77 = (var_argv.v.pair.car ? *(var_argv.v.pair.car) : LVI_NIL());
lval var_78;
var_78 = LVI_STRING("-g");
lval var_79;
var_79 = LVI_BOOL(strcmp(var_77.v.str, var_78.v.str) == 0);
var_74 = var_79;
if (LV_IS_FALSE(var_74)) { break; }
} while (0);
if (LV_IS_FALSE(var_74)) {
(void)
 LVI_BOOL(false);
} else {
lval var_81;
var_81 = LVI_BOOL(true);
var_2 = var_81;
lval var_82;
if (var_argv.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_82 = (var_argv.v.pair.cdr ? *(var_argv.v.pair.cdr) : LVI_NIL());
var_argv = var_82;
(void)
 var_argv;
}
lval var_84;
var_84 = LVI_BOOL(false);
do {
lval var_85;
var_85 = LVI_BOOL(var_argv.vt == LV_NIL);
var_84 = var_85;
if (!LV_IS_FALSE(var_84)) { break; }
lval var_86;
if (var_argv.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_86 = (var_argv.v.pair.cdr ? *(var_argv.v.pair.cdr) : LVI_NIL());
lval var_87;
var_87 = LVI_BOOL(var_86.vt == LV_NIL);
var_84 = var_87;
if (!LV_IS_FALSE(var_84)) { break; }
} while (0);
if (LV_IS_FALSE(var_84)) {
(void)
 LVI_BOOL(false);
} else {
lval var_89;
var_89 = LVI_STRING("usage: ");
lval var_90;
var_90 = LVI_STRING(" [-g] file-to-split output-dir\n");
lval var_91;
{
lval vs[4];
vs[0] = var_stderr;
vs[1] = var_89;
vs[2] = var_cmd_name;
vs[3] = var_90;
var_91 = gen_list(4, vs, NULL);
}
{
lval vs[6];
vs[0] = var_91;
var_91 = wile_write_string(NULL, vs);
}
lval var_92;
var_92 = LVI_INT(0);
exit(var_92.v.iv);
}
lval var_95;
var_95 = LVI_STRING("cadr");
lval var_96;
{
char* cp = strchr(var_95.v.str, 'r');
var_96 = var_argv;
while (*(--cp) != 'c') {
if (var_96.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_96 = (var_96.v.pair.car ? *(var_96.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_96 = (var_96.v.pair.cdr ? *(var_96.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_95.v.str);
}
}
}
lval var_97;
{
struct stat sb;
var_97 = LVI_BOOL(stat(var_96.v.str, &sb) == 0 && S_ISDIR(sb.st_mode));
}
if (LV_IS_FALSE(var_97)) {
lval var_98;
var_98 = LVI_STRING("output directory doesn\'t exist or isn\'t a directory\n");
lval var_99;
{
lval vs[2];
vs[0] = var_stderr;
vs[1] = var_98;
var_99 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_99;
var_99 = wile_write_string(NULL, vs);
}
lval var_100;
var_100 = LVI_INT(1);
exit(var_100.v.iv);
} else {
(void)
 LVI_BOOL(false);
}
lval var_103;
lval var_104;
if (var_argv.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_104 = (var_argv.v.pair.car ? *(var_argv.v.pair.car) : LVI_NIL());
var_103 = var_104;
lval var_105;
lval var_106;
var_106 = LVI_STRING("cadr");
lval var_107;
{
char* cp = strchr(var_106.v.str, 'r');
var_107 = var_argv;
while (*(--cp) != 'c') {
if (var_107.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_107 = (var_107.v.pair.car ? *(var_107.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_107 = (var_107.v.pair.cdr ? *(var_107.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_106.v.str);
}
}
}
lval var_108;
var_108 = LVI_STRING("/");
lval var_109;
{
lval vs[2];
vs[0] = var_107;
vs[1] = var_108;
var_109 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_109;
var_109 = wile_string_append(NULL, vs);
}
var_105 = var_109;
lval var_110;
lval var_111;
var_111 = LVI_STRING("r");
lval var_112;
{
FILE* fp = fopen(var_103.v.str, var_111.v.str);
if (fp) {
var_112 = LVI_FPORT(fp);
} else {
var_112 = LVI_BOOL(false);
}
}
var_110 = var_112;
lval var_113;
lval var_114;
lval var_115[6];
var_115[0] = var_110;
var_114 = fn_1(NULL, var_115);
var_113 = var_114;
lval var_117;
lval var_118;
var_118 = LVI_CHAR(46);
lval var_119;
if (var_103.vt != LV_STRING || var_118.vt != LV_CHAR) {
WILE_EX("string-find-last-char", "expects a string and a character input");
}
{
char* pos = strrchr(var_103.v.str, var_118.v.chr);
if (pos) {
var_119 = LVI_INT(pos - var_103.v.str);
} else {
var_119 = LVI_BOOL(false);
}
}
var_117 = var_119;
lval var_120;
lval var_121;
if (LV_IS_FALSE(var_117)) {
var_121 = var_103;
} else {
lval var_122;
var_122 = LVI_INT(0);
lval var_123;
if (var_103.vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_103.v.str);
if (var_122.v.iv < 0 || (size_t) var_122.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
if (var_117.v.iv < var_122.v.iv || (size_t) var_117.v.iv >= len) {
WILE_EX("string-copy", "end index is out of range");
}
var_123.vt = LV_STRING;
var_123.v.str = LISP_ALLOC(char, 1 + var_117.v.iv - var_122.v.iv);
LISP_ASSERT(var_123.v.str != NULL);
memcpy(var_123.v.str, var_103.v.str + var_122.v.iv, var_117.v.iv - var_122.v.iv);
var_123.v.str[var_117.v.iv - var_122.v.iv] = '\0';
}
var_121 = var_123;
}
var_120 = var_121;
lval var_124;
lval var_125;
if (LV_IS_FALSE(var_117)) {
lval var_126;
var_126 = LVI_STRING("");
var_125 = var_126;
} else {
lval var_127;
if (var_103.vt != LV_STRING) {
WILE_EX("string-copy", "expects a string input");
}
{
size_t len = strlen(var_103.v.str);
if (var_117.v.iv < 0 || (size_t) var_117.v.iv >= len) {
WILE_EX("string-copy", "start index is out of range");
}
var_127 = LVI_STRING(var_103.v.str + var_117.v.iv);
}
var_125 = var_127;
}
var_124 = var_125;
lval var_128;
lval var_129;
var_129 = LVI_STRING("(--8><--)+$");
var_128 = var_129;
lval var_130;
lval var_131;
lval var_132[6];
var_132[0] = var_128;
var_132[1] = var_113;
var_131 = fn_4(NULL, var_132);
var_130 = var_131;
lval var_134;
lval var_135;
if (var_130.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_135 = (var_130.v.pair.car ? *(var_130.v.pair.car) : LVI_NIL());
var_134 = var_135;
lval var_136;
lval var_137;
var_137 = LVI_STRING("cadr");
lval var_138;
{
char* cp = strchr(var_137.v.str, 'r');
var_138 = var_130;
while (*(--cp) != 'c') {
if (var_138.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_138 = (var_138.v.pair.car ? *(var_138.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_138 = (var_138.v.pair.cdr ? *(var_138.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_137.v.str);
}
}
}
var_136 = var_138;
(void)
 LVI_INT(0);
{
lval vs[6];
vs[0] = var_110;
(void)
 wile_closeport(NULL, vs);
}
lval var_143;
var_143 = LVI_BOOL(var_136.vt == LV_NIL);
if (LV_IS_FALSE(var_143)) {
(void)
 LVI_BOOL(false);
} else {
lval var_145;
var_145 = LVI_STRING("there is no split directive!\n");
lval var_146;
{
lval vs[1];
vs[0] = var_145;
var_146 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = var_146;
var_146 = wile_write_string(NULL, vs);
}
lval var_147;
var_147 = LVI_INT(1);
exit(var_147.v.iv);
}
lval var_150;
var_150 = LVI_BOOL(false);
do {
lval var_151;
var_151 = LVI_STRING(".scm");
lval var_152;
var_152 = LVI_BOOL(strcmp(var_124.v.str, var_151.v.str) == 0);
var_150 = var_152;
if (!LV_IS_FALSE(var_150)) { break; }
lval var_153;
var_153 = LVI_STRING(".c");
lval var_154;
var_154 = LVI_BOOL(strcmp(var_124.v.str, var_153.v.str) == 0);
var_150 = var_154;
if (!LV_IS_FALSE(var_150)) { break; }
} while (0);
if (LV_IS_FALSE(var_150)) {
lval var_155;
var_155 = LVI_STRING("error: don\'t know how to handle ");
lval var_156;
var_156 = LVI_STRING(" files yet!\n");
lval var_157;
{
lval vs[3];
vs[0] = var_155;
vs[1] = var_124;
vs[2] = var_156;
var_157 = gen_list(3, vs, NULL);
}
{
lval vs[6];
vs[0] = var_157;
var_157 = wile_write_string(NULL, vs);
}
lval var_158;
var_158 = LVI_INT(1);
exit(var_158.v.iv);
} else {
(void)
 LVI_BOOL(false);
}
lptr var_162[5];
var_162[4] = &(var_134);
var_162[3] = &(var_128);
var_162[2] = &(var_124);
var_162[1] = &(var_120);
var_162[0] = &(var_105);
lval var_246;
var_246 = LVI_INT(0);
lval var_247;
lval var_248[6];
var_248[0] = var_136;
var_248[1] = var_246;
var_247 = fn_161(var_162, var_248);
return var_247;
}

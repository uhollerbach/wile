// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

extern lval var_argv;
extern lval var_cmd_name;
extern lval var_stdin;
extern lval var_stdout;
extern lval var_stderr;
extern lval var_pi;
extern lval var_euler_gamma;
extern lval var_show_sign;
extern lval var_int_base;
extern lval var_flt_base;
extern lval var_flt_precision;
#include "wile-rtl2.h"
static lval fn_4(lptr*, lptr);	// (map2 proc acc ls)

// definitions

// @@@ car @@@ bld-rtl-dir/wile-rtl2-000029.scm:17 @@@ fn_11 @@@
static lval fn_11(lptr* var_12, lptr var_13)
{
lval var_15;
if (var_13[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_15 = (var_13[0].v.pair.car ? *(var_13[0].v.pair.car) : LVI_NIL());
return var_15;
}
// end of prim fn_11

// @@@ cdr @@@ bld-rtl-dir/wile-rtl2-000029.scm:17 @@@ fn_19 @@@
static lval fn_19(lptr* var_20, lptr var_21)
{
lval var_23;
if (var_21[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_23 = (var_21[0].v.pair.cdr ? *(var_21[0].v.pair.cdr) : LVI_NIL());
return var_23;
}
// end of prim fn_19

// @@@ (map2 proc acc ls) @@@ bld-rtl-dir/wile-rtl2-000029.scm:14 @@@ fn_4 @@@
static lval fn_4(lptr* var_5, lptr var_6)
{
lbl_7:;
lval var_8;
lval var_9;
if (var_6[2].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_9 = (var_6[2].v.pair.car ? *(var_6[2].v.pair.car) : LVI_NIL());
lval var_10;
var_10 = LVI_BOOL(var_9.vt == LV_NIL);
if (LV_IS_FALSE(var_10)) {
lval var_16;
{
lval vs[8];
vs[0] = LVI_PROC(fn_11,NULL,1);
vs[1] = var_6[2];
var_16 = wile_map1(NULL, vs);
}
lval var_17;
{
lval vs[2];
vs[0] = var_6[0];
vs[1] = var_16;
var_17 = wile_gen_list(2, vs, NULL);
}
var_17 = wile_apply_function(&(var_17), __FILE__, __LINE__);
lval var_18;
{
lptr p1 = NULL, p2 = NULL;
if (var_17.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_17;
}
if (var_6[1].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_6[1];
}
var_18 = LVI_PAIR(p1, p2);
}
lval var_24;
{
lval vs[8];
vs[0] = LVI_PROC(fn_19,NULL,1);
vs[1] = var_6[2];
var_24 = wile_map1(NULL, vs);
}
lval var_27[8];
var_27[0] = var_6[0];
var_27[1] = var_18;
var_27[2] = var_24;
var_6[0] = var_27[0];
var_6[1] = var_27[1];
var_6[2] = var_27[2];
goto lbl_7;	// selfie
} else {
lval var_28;
{
lval vs[8];
vs[0] = var_6[1];
var_28 = wile_list_reverse(NULL, vs);
}
var_8 = var_28;
}
return var_8;
}
// end of function fn_4

// @@@ list-length @@@ bld-rtl-dir/wile-rtl2-000029.scm:19 @@@ fn_32 @@@
static lval fn_32(lptr* var_33, lptr var_34)
{
lval var_36;
{
lval vs[8];
vs[0] = var_34[0];
var_36 = wile_list_length(NULL, vs);
}
return var_36;
}
// end of prim fn_32

// @@@ min/i @@@ bld-rtl-dir/wile-rtl2-000029.scm:20 @@@ fn_39 @@@
static lval fn_39(lptr* var_40, lptr var_41)
{
lval var_43;
var_43 = LVI_INT((var_41[0].v.iv < var_41[1].v.iv) ? var_41[0].v.iv : var_41[1].v.iv);
return var_43;
}
// end of prim fn_39

// @@@ max/i @@@ bld-rtl-dir/wile-rtl2-000029.scm:20 @@@ fn_45 @@@
static lval fn_45(lptr* var_46, lptr var_47)
{
lval var_49;
var_49 = LVI_INT((var_47[0].v.iv > var_47[1].v.iv) ? var_47[0].v.iv : var_47[1].v.iv);
return var_49;
}
// end of prim fn_45

// @@@ (map proc lst . lsts) @@@ bld-rtl-dir/wile-rtl2-000029.scm:13 @@@ wile_map @@@
lval wile_map(lptr* var_1, lptr var_2)
{
lval var_29;
lval var_30;
{
lptr p1 = NULL, p2 = NULL;
if (var_2[1].vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_2[1];
}
if (var_2[2].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_2[2];
}
var_30 = LVI_PAIR(p1, p2);
}
var_29 = var_30;
lval var_31;
lval var_37;
{
lval vs[8];
vs[0] = LVI_PROC(fn_32,NULL,1);
vs[1] = var_29;
var_37 = wile_map1(NULL, vs);
}
var_31 = var_37;
lval var_38;
lval var_44;
{
lval vs[8];
vs[0] = LVI_PROC(fn_39,NULL,2);
vs[1] = var_31;
var_44 = wile_foldl1(NULL, vs);
}
lval var_50;
{
lval vs[8];
vs[0] = LVI_PROC(fn_45,NULL,2);
vs[1] = var_31;
var_50 = wile_foldl1(NULL, vs);
}
lval var_51;
switch (TYPE_COMBO(var_44.vt,var_50.vt)) {
case TYPE_COMBO(LV_INT,LV_INT):
var_51 = LVI_BOOL(var_44.v.iv != var_50.v.iv);
break;
case TYPE_COMBO(LV_INT,LV_RAT):
var_51 = LVI_BOOL(var_44.v.iv * var_50.v.irv.den != var_50.v.irv.num);
break;
case TYPE_COMBO(LV_INT,LV_REAL):
var_51 = LVI_BOOL(var_44.v.iv != var_50.v.rv);
break;
case TYPE_COMBO(LV_RAT,LV_INT):
var_51 = LVI_BOOL(var_44.v.irv.num != var_50.v.iv * var_44.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_RAT):
var_51 = LVI_BOOL(var_44.v.irv.num * var_50.v.irv.den != var_50.v.irv.num * var_44.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_REAL):
var_51 = LVI_BOOL(var_44.v.irv.num != var_50.v.rv * var_44.v.irv.den);
break;
case TYPE_COMBO(LV_REAL,LV_INT):
var_51 = LVI_BOOL(var_44.v.rv != var_50.v.iv);
break;
case TYPE_COMBO(LV_REAL,LV_RAT):
var_51 = LVI_BOOL(var_44.v.rv * var_50.v.irv.den != var_50.v.irv.num);
break;
case TYPE_COMBO(LV_REAL,LV_REAL):
var_51 = LVI_BOOL(var_44.v.rv != var_50.v.rv);
break;
default:
WILE_EX("!=", "inputs are not real-valued numbers");
break;
}
if (LV_IS_FALSE(var_51)) {
lval var_52;
var_52 = LVI_NIL();
lval var_55[8];
var_55[0] = var_2[0];
var_55[1] = var_52;
var_55[2] = var_29;
var_2[0] = var_55[0];
var_2[1] = var_55[1];
var_2[2] = var_55[2];
TAIL_CALL fn_4(NULL, var_2);
} else {
lval var_56;
var_56 = LVI_STRING("map got lists of different lengths");
lval var_57;
{
lval vs[1];
vs[0] = var_56;
var_57 = wile_gen_list(1, vs, NULL);
}
if (var_57.vt == LV_PAIR && (var_57.v.pair.cdr == NULL || var_57.v.pair.cdr->vt == LV_NIL)) {
var_57 = (var_57.v.pair.car ? *(var_57.v.pair.car) : LVI_NIL());
}
cachalot->errval = new_lv(LV_NIL);
*(cachalot->errval) = var_57;
cachalot->l_whence = 0;
cachalot->c_whence = LISP_WHENCE;
longjmp(cachalot->cenv, 1);
var_38 = var_57;
}
return var_38;
}
// end of function wile_map

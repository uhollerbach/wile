// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

extern lval var_argv;
extern lval var_cmd_name;
extern lval var_stdin;
extern lval var_stdout;
extern lval var_stderr;
extern lval var_pi;
extern lval var_euler_gamma;
extern lval var_show_sign;
extern lval var_int_base;
extern lval var_flt_base;
extern lval var_flt_precision;
#include "wile-rtl2.h"
static lval fn_4(lptr*, lptr);	// (sf m v)
static lval fn_5(lptr*, lptr);	// (t1 n m)
static lval fn_6(lptr*, lptr);	// (t2 i n m)
static lval fn_7(lptr*, lptr);	// (t3 m)
static lval fn_16(lptr*, lptr);
static lval fn_93(lptr*, lptr);

// definitions

// @@@ lambda (e1 e2) @@@ bld-rtl-dir/wile-rtl2-000074.scm:19 @@@ fn_16 @@@
static lval fn_16(lptr* var_17, lptr var_18)
{
lval var_20;
{
lval vs[2];
vs[0] = V_CLOS(var_17,0);
vs[1] = var_18[1];
var_20 = wile_gen_list(2, vs, NULL);
}
{
lval vs[8];
vs[0] = var_20;
var_20 = wile_multiply(NULL, vs);
}
lval var_21;
{
lval vs[2];
vs[0] = var_18[0];
vs[1] = var_20;
var_21 = wile_gen_list(2, vs, NULL);
}
{
lval vs[8];
vs[0] = var_21;
var_21 = wile_subtract(NULL, vs);
}
return var_21;
}
// end of lambda fn_16

// @@@ (sf m v) @@@ bld-rtl-dir/wile-rtl2-000074.scm:14 @@@ fn_4 @@@
static lval fn_4(lptr* var_8, lptr var_9)
{
lval var_11;
lval var_12;
var_12 = LVI_BOOL(var_9[0].vt == LV_NIL);
if (LV_IS_FALSE(var_12)) {
lval var_13;
lval var_14;
if (var_9[1].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_14 = (var_9[1].v.pair.car ? *(var_9[1].v.pair.car) : LVI_NIL());
var_13 = var_14;
lval var_15;
if (var_9[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_15 = (var_9[0].v.pair.cdr ? *(var_9[0].v.pair.cdr) : LVI_NIL());
MK_CLOS(var_17,1);
P_CLOS(var_17,0) = &(var_13);
lval var_22;
if (var_9[1].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_22 = (var_9[1].v.pair.cdr ? *(var_9[1].v.pair.cdr) : LVI_NIL());
lval var_23;
var_23 = LVI_STRING("cdar");
lval var_24;
{
char* cp = strchr(var_23.v.str, 'r');
var_24 = var_9[0];
while (*(--cp) != 'c') {
if (var_24.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_24 = (var_24.v.pair.car ? *(var_24.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_24 = (var_24.v.pair.cdr ? *(var_24.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_23.v.str);
}
}
}
lval var_25;
{
lval vs[1];
vs[0] = var_24;
var_25 = wile_gen_list(1, vs, NULL);
}
{
lval vs[8];
vs[0] = LVI_PROC(fn_16,var_17,2);
vs[1] = var_22;
vs[2] = var_25;
var_25 = wile_map(NULL, vs);
}
lval var_26;
lval var_27[8];
var_27[0] = var_15;
var_27[1] = var_25;
var_26 = fn_4(NULL, var_27);
lval var_29;
{
lptr p1 = NULL, p2 = NULL;
if (var_13.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_13;
}
if (var_26.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_26;
}
var_29 = LVI_PAIR(p1, p2);
}
var_11 = var_29;
} else {
lval var_30;
var_30 = LVI_NIL();
var_11 = var_30;
}
return var_11;
}
// end of function fn_4

// @@@ (t1 n m) @@@ bld-rtl-dir/wile-rtl2-000074.scm:21 @@@ fn_5 @@@
static lval fn_5(lptr* var_31, lptr var_32)
{
lval var_34;
lval var_35;
switch (var_32[0].vt) {
case LV_REAL:
var_35 = LVI_BOOL(var_32[0].v.rv == 0.0);
break;
case LV_RAT:
var_35 = LVI_BOOL((var_32[0].v.irv.num == 0 && var_32[0].v.irv.den != 0));
break;
case LV_INT:
var_35 = LVI_BOOL(var_32[0].v.iv == 0);
break;
case LV_CMPLX:
var_35 = LVI_BOOL(CREAL(var_32[0].v.cv) == 0.0 && CIMAG(var_32[0].v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
if (LV_IS_FALSE(var_35)) {
lval var_36;
lval var_37;
var_37 = LVI_INT(1);
lval var_38;
{
lval vs[2];
vs[0] = var_32[0];
vs[1] = var_37;
var_38 = wile_gen_list(2, vs, NULL);
}
{
lval vs[8];
vs[0] = var_38;
var_38 = wile_subtract(NULL, vs);
}
lval var_39;
if (var_32[1].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_39 = (var_32[1].v.pair.cdr ? *(var_32[1].v.pair.cdr) : LVI_NIL());
lval var_40;
lval var_41[8];
var_41[0] = var_38;
var_41[1] = var_39;
var_40 = fn_5(NULL, var_41);
var_36 = var_40;
lval var_43;
lval var_44;
if (var_32[1].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_44 = (var_32[1].v.pair.car ? *(var_32[1].v.pair.car) : LVI_NIL());
var_43 = var_44;
lval var_45;
if (var_43.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_45 = (var_43.v.pair.car ? *(var_43.v.pair.car) : LVI_NIL());
lval var_46;
if (var_36.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_46 = (var_36.v.pair.car ? *(var_36.v.pair.car) : LVI_NIL());
lval var_47;
{
lptr p1 = NULL, p2 = NULL;
if (var_45.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_45;
}
if (var_46.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_46;
}
var_47 = LVI_PAIR(p1, p2);
}
lval var_48;
if (var_43.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_48 = (var_43.v.pair.cdr ? *(var_43.v.pair.cdr) : LVI_NIL());
lval var_49;
var_49 = LVI_STRING("cadr");
lval var_50;
{
char* cp = strchr(var_49.v.str, 'r');
var_50 = var_36;
while (*(--cp) != 'c') {
if (var_50.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_50 = (var_50.v.pair.car ? *(var_50.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_50 = (var_50.v.pair.cdr ? *(var_50.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_49.v.str);
}
}
}
lval var_51;
{
lptr p1 = NULL, p2 = NULL;
if (var_48.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_48;
}
if (var_50.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_50;
}
var_51 = LVI_PAIR(p1, p2);
}
lval var_52;
{
lval vs[2];
vs[0] = var_47;
vs[1] = var_51;
var_52 = wile_gen_list(2, vs, NULL);
}
var_34 = var_52;
} else {
lval var_53;
var_53 = LVI_NIL();
lval var_54;
{
lval vs[2];
vs[0] = var_53;
vs[1] = var_32[1];
var_54 = wile_gen_list(2, vs, NULL);
}
var_34 = var_54;
}
return var_34;
}
// end of function fn_5

// @@@ (t2 i n m) @@@ bld-rtl-dir/wile-rtl2-000074.scm:27 @@@ fn_6 @@@
static lval fn_6(lptr* var_55, lptr var_56)
{
lval var_58;
lval var_59;
switch (TYPE_COMBO(var_56[0].vt,var_56[1].vt)) {
case TYPE_COMBO(LV_INT,LV_INT):
var_59 = LVI_BOOL(var_56[0].v.iv == var_56[1].v.iv);
break;
case TYPE_COMBO(LV_INT,LV_RAT):
var_59 = LVI_BOOL(var_56[0].v.iv * var_56[1].v.irv.den == var_56[1].v.irv.num);
break;
case TYPE_COMBO(LV_INT,LV_REAL):
var_59 = LVI_BOOL(var_56[0].v.iv == var_56[1].v.rv);
break;
case TYPE_COMBO(LV_RAT,LV_INT):
var_59 = LVI_BOOL(var_56[0].v.irv.num == var_56[1].v.iv * var_56[0].v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_RAT):
var_59 = LVI_BOOL(var_56[0].v.irv.num * var_56[1].v.irv.den == var_56[1].v.irv.num * var_56[0].v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_REAL):
var_59 = LVI_BOOL(var_56[0].v.irv.num == var_56[1].v.rv * var_56[0].v.irv.den);
break;
case TYPE_COMBO(LV_REAL,LV_INT):
var_59 = LVI_BOOL(var_56[0].v.rv == var_56[1].v.iv);
break;
case TYPE_COMBO(LV_REAL,LV_RAT):
var_59 = LVI_BOOL(var_56[0].v.rv * var_56[1].v.irv.den == var_56[1].v.irv.num);
break;
case TYPE_COMBO(LV_REAL,LV_REAL):
var_59 = LVI_BOOL(var_56[0].v.rv == var_56[1].v.rv);
break;
default:
WILE_EX("==", "inputs are not real-valued numbers");
break;
}
if (LV_IS_FALSE(var_59)) {
lval var_60;
lval var_61;
var_61 = LVI_INT(1);
lval var_62;
{
lval vs[2];
vs[0] = var_56[0];
vs[1] = var_61;
var_62 = wile_gen_list(2, vs, NULL);
}
{
lval vs[8];
vs[0] = var_62;
var_62 = wile_add(NULL, vs);
}
var_60 = var_62;
lval var_63;
lval var_64;
lval var_65[8];
var_65[0] = var_60;
var_65[1] = var_56[2];
var_64 = fn_5(NULL, var_65);
var_63 = var_64;
lval var_67;
if (var_63.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_67 = (var_63.v.pair.car ? *(var_63.v.pair.car) : LVI_NIL());
lval var_68;
{
lval vs[8];
vs[0] = var_67;
var_68 = wile_list_reverse(NULL, vs);
}
lval var_69;
var_69 = LVI_STRING("cadr");
lval var_70;
{
char* cp = strchr(var_69.v.str, 'r');
var_70 = var_63;
while (*(--cp) != 'c') {
if (var_70.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_70 = (var_70.v.pair.car ? *(var_70.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_70 = (var_70.v.pair.cdr ? *(var_70.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_69.v.str);
}
}
}
lval var_71;
lval var_72[8];
var_72[0] = var_60;
var_72[1] = var_56[1];
var_72[2] = var_70;
var_71 = fn_6(NULL, var_72);
lval var_74;
{
lptr p1 = NULL, p2 = NULL;
if (var_68.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_68;
}
if (var_71.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_71;
}
var_74 = LVI_PAIR(p1, p2);
}
var_58 = var_74;
} else {
lval var_75;
var_75 = LVI_NIL();
var_58 = var_75;
}
return var_58;
}
// end of function fn_6

// @@@ (t3 m) @@@ bld-rtl-dir/wile-rtl2-000074.scm:33 @@@ fn_7 @@@
static lval fn_7(lptr* var_76, lptr var_77)
{
lval var_79;
var_79 = LVI_INT(0);
lval var_80;
{
lval vs[8];
vs[0] = var_77[0];
var_80 = wile_list_length(NULL, vs);
}
lval var_81;
lval var_82[8];
var_82[0] = var_79;
var_82[1] = var_80;
var_82[2] = var_77[0];
var_81 = fn_6(NULL, var_82);
lval var_84;
{
lval vs[8];
vs[0] = var_81;
var_84 = wile_list_reverse(NULL, vs);
}
return var_84;
}
// end of function fn_7

// @@@ lambda (m v) @@@ bld-rtl-dir/wile-rtl2-000074.scm:37 @@@ fn_93 @@@
static lval fn_93(lptr* var_94, lptr var_95)
{
lval var_97;
{
lval vs[2];
vs[0] = var_95[1];
vs[1] = var_95[0];
var_97 = wile_gen_list(2, vs, NULL);
}
{
lval vs[8];
vs[0] = var_97;
var_97 = wile_divide(NULL, vs);
}
return var_97;
}
// end of lambda fn_93

// @@@ (cholesky-solve mat vec) @@@ bld-rtl-dir/wile-rtl2-000074.scm:13 @@@ wile_cholesky_solve @@@
lval wile_cholesky_solve(lptr* var_1, lptr var_2)
{
lval var_85;
lval var_86;
if (var_2[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_86 = (var_2[0].v.pair.car ? *(var_2[0].v.pair.car) : LVI_NIL());
var_85 = var_86;
lval var_87;
lval var_88;
var_88 = LVI_STRING("cadr");
lval var_89;
{
char* cp = strchr(var_88.v.str, 'r');
var_89 = var_2[0];
while (*(--cp) != 'c') {
if (var_89.vt != LV_PAIR) {
WILE_EX("cxr", "input does not have the right structure!");
}
if (*cp == 'a') {
var_89 = (var_89.v.pair.car ? *(var_89.v.pair.car) : LVI_NIL());
} else if (*cp == 'd') {
var_89 = (var_89.v.pair.cdr ? *(var_89.v.pair.cdr) : LVI_NIL());
} else {
WILE_EX("cxr", "got malformed control string '%s'", var_88.v.str);
}
}
}
var_87 = var_89;
lval var_90;
lval var_91[8];
var_91[0] = var_87;
var_90 = fn_7(NULL, var_91);
MK_CLOS(var_94,0);
lval var_98;
lval var_99[8];
var_99[0] = var_87;
var_99[1] = var_2[1];
var_98 = fn_4(NULL, var_99);
lval var_101;
{
lval vs[1];
vs[0] = var_98;
var_101 = wile_gen_list(1, vs, NULL);
}
{
lval vs[8];
vs[0] = LVI_PROC(fn_93,var_94,2);
vs[1] = var_85;
vs[2] = var_101;
var_101 = wile_map(NULL, vs);
}
lval var_102;
{
lval vs[8];
vs[0] = var_101;
var_102 = wile_list_reverse(NULL, vs);
}
lval var_103;
lval var_104[8];
var_104[0] = var_90;
var_104[1] = var_102;
var_103 = fn_4(NULL, var_104);
lval var_106;
{
lval vs[8];
vs[0] = var_103;
var_106 = wile_list_reverse(NULL, vs);
}
return var_106;
}
// end of function wile_cholesky_solve

// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

extern lval var_argv;
extern lval var_cmd_name;
extern lval var_stdin;
extern lval var_stdout;
extern lval var_stderr;
extern lval var_pi;
extern lval var_euler_gamma;
extern lval var_show_sign;
extern lval var_int_base;
extern lval var_flt_base;
extern lval var_flt_precision;
#include "wile-rtl2.h"
static lval fn_4(lptr*, lptr);	// (wk1 r rs)
static lval fn_5(lptr*, lptr);	// (wk2 r1 s r2)
static lval fn_6(lptr*, lptr);	// (wk3 ms p us)
static lval fn_13(lptr*, lptr);
static lval fn_25(lptr*, lptr);
static lval fn_50(lptr*, lptr);

// definitions

// lambda (p)
static lval fn_13(lptr* var_14, lptr var_15)
{
lval var_17;
{
lval vs[2];
vs[0] = var_15[0];
vs[1] = (*(var_14[0]));
var_17 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_17;
var_17 = wile_divide(NULL, vs);
}
return var_17;
}
// end of lambda fn_13

// (wk1 r rs)
static lval fn_4(lptr* var_7, lptr var_8)
{
lval var_10;
lval var_11;
switch (var_8[0].vt) {
case LV_REAL:
var_11 = LVI_BOOL(var_8[0].v.rv == 0.0);
break;
case LV_RAT:
var_11 = LVI_BOOL((var_8[0].v.irv.num == 0 && var_8[0].v.irv.den != 0));
break;
case LV_INT:
var_11 = LVI_BOOL(var_8[0].v.iv == 0);
break;
case LV_CMPLX:
var_11 = LVI_BOOL(CREAL(var_8[0].v.cv) == 0.0 && CIMAG(var_8[0].v.cv) == 0.0);
break;
default:
WILE_EX("zero?", "expects a real-valued number");
}
if (LV_IS_FALSE(var_11)) {
lval var_12;
var_12 = LVI_INT(1);
lptr var_14[1];
var_14[0] = &(var_8[0]);
lval var_18;
var_18 = LVI_NIL();
{
lval vs[6];
vs[0] = LVI_PROC(fn_13,var_14,1);
vs[1] = var_8[1];
vs[2] = var_18;
var_18 = wile_map(NULL, vs);
}
lval var_19;
{
lptr p1 = NULL, p2 = NULL;
if (var_12.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_12;
}
if (var_18.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_18;
}
var_19 = LVI_PAIR(p1, p2);
}
var_10 = var_19;
} else {
lval var_20;
var_20 = LVI_STRING("Zero pivot in Cholesky decomposition");
lval var_21;
{
lval vs[1];
vs[0] = var_20;
var_21 = gen_list(1, vs, NULL);
}
if (var_21.vt == LV_PAIR && (var_21.v.pair.cdr == NULL || var_21.v.pair.cdr->vt == LV_NIL)) {
var_21 = (var_21.v.pair.car ? *(var_21.v.pair.car) : LVI_NIL());
}
cachalot->errval = new_lv(LV_NIL);
*(cachalot->errval) = var_21;
cachalot->l_whence = 0;
cachalot->c_whence = LISP_WHENCE;
longjmp(cachalot->cenv, 1);
var_10 = var_21;
}
return var_10;
}
// end of function fn_4

// lambda (e1 e2)
static lval fn_25(lptr* var_26, lptr var_27)
{
lval var_29;
{
lval vs[2];
vs[0] = (*(var_26[0]));
vs[1] = var_27[1];
var_29 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_29;
var_29 = wile_multiply(NULL, vs);
}
lval var_30;
{
lval vs[2];
vs[0] = var_27[0];
vs[1] = var_29;
var_30 = gen_list(2, vs, NULL);
}
{
lval vs[6];
vs[0] = var_30;
var_30 = wile_subtract(NULL, vs);
}
return var_30;
}
// end of lambda fn_25

// (wk2 r1 s r2)
static lval fn_5(lptr* var_22, lptr var_23)
{
lptr var_26[1];
var_26[0] = &(var_23[1]);
lval var_31;
{
lval vs[1];
vs[0] = var_23[2];
var_31 = gen_list(1, vs, NULL);
}
{
lval vs[6];
vs[0] = LVI_PROC(fn_25,var_26,2);
vs[1] = var_23[0];
vs[2] = var_31;
var_31 = wile_map(NULL, vs);
}
return var_31;
}
// end of function fn_5

// (wk3 ms p us)
static lval fn_6(lptr* var_32, lptr var_33)
{
lval var_35;
lval var_36;
var_36 = LVI_BOOL(var_33[0].vt == LV_NIL);
if (LV_IS_FALSE(var_36)) {
lval var_37;
if (var_33[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_37 = (var_33[0].v.pair.car ? *(var_33[0].v.pair.car) : LVI_NIL());
lval var_38;
if (var_33[2].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_38 = (var_33[2].v.pair.car ? *(var_33[2].v.pair.car) : LVI_NIL());
lval var_39;
lval var_40[6];
var_40[0] = var_37;
var_40[1] = var_38;
var_40[2] = var_33[1];
var_39 = fn_5(NULL, var_40);
lval var_42;
if (var_33[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_42 = (var_33[0].v.pair.cdr ? *(var_33[0].v.pair.cdr) : LVI_NIL());
lval var_43;
if (var_33[1].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_43 = (var_33[1].v.pair.cdr ? *(var_33[1].v.pair.cdr) : LVI_NIL());
lval var_44;
if (var_33[2].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_44 = (var_33[2].v.pair.cdr ? *(var_33[2].v.pair.cdr) : LVI_NIL());
lval var_45;
lval var_46[6];
var_46[0] = var_42;
var_46[1] = var_43;
var_46[2] = var_44;
var_45 = fn_6(NULL, var_46);
lval var_48;
{
lptr p1 = NULL, p2 = NULL;
if (var_39.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_39;
}
if (var_45.vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_45;
}
var_48 = LVI_PAIR(p1, p2);
}
var_35 = var_48;
} else {
lval var_49;
var_49 = LVI_NIL();
var_35 = var_49;
}
return var_35;
}
// end of function fn_6

// lambda (ms ds us)
static lval fn_50(lptr* var_51, lptr var_52)
{
lbl_53:;
lval var_54;
lval var_55;
var_55 = LVI_BOOL(var_52[0].vt == LV_NIL);
if (LV_IS_FALSE(var_55)) {
lval var_56;
lval var_57;
if (var_52[0].vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_57 = (var_52[0].v.pair.car ? *(var_52[0].v.pair.car) : LVI_NIL());
var_56 = var_57;
lval var_58;
lval var_59;
if (var_56.vt != LV_PAIR) {
WILE_EX("car", "input is not a pair!");
}
var_59 = (var_56.v.pair.car ? *(var_56.v.pair.car) : LVI_NIL());
var_58 = var_59;
lval var_60;
lval var_61;
if (var_56.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_61 = (var_56.v.pair.cdr ? *(var_56.v.pair.cdr) : LVI_NIL());
var_60 = var_61;
lval var_62;
lval var_63;
lval var_64[6];
var_64[0] = var_58;
var_64[1] = var_60;
var_63 = fn_4(NULL, var_64);
var_62 = var_63;
lval var_66;
if (var_52[0].vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_66 = (var_52[0].v.pair.cdr ? *(var_52[0].v.pair.cdr) : LVI_NIL());
lval var_67;
if (var_62.vt != LV_PAIR) {
WILE_EX("cdr", "input is not a pair!");
}
var_67 = (var_62.v.pair.cdr ? *(var_62.v.pair.cdr) : LVI_NIL());
lval var_68;
lval var_69[6];
var_69[0] = var_66;
var_69[1] = var_60;
var_69[2] = var_67;
var_68 = fn_6(NULL, var_69);
lval var_71;
{
lptr p1 = NULL, p2 = NULL;
if (var_58.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_58;
}
if (var_52[1].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_52[1];
}
var_71 = LVI_PAIR(p1, p2);
}
lval var_72;
{
lptr p1 = NULL, p2 = NULL;
if (var_62.vt != LV_NIL) {
p1 = new_lv(LV_NIL);
*p1 = var_62;
}
if (var_52[2].vt != LV_NIL) {
p2 = new_lv(LV_NIL);
*p2 = var_52[2];
}
var_72 = LVI_PAIR(p1, p2);
}
lval var_75[6];
var_75[0] = var_68;
var_75[1] = var_71;
var_75[2] = var_72;
var_52[0] = var_75[0];
var_52[1] = var_75[1];
var_52[2] = var_75[2];
goto lbl_53;	// selfie
} else {
lval var_76;
{
lval vs[6];
vs[0] = var_52[1];
var_76 = wile_list_reverse(NULL, vs);
}
lval var_77;
{
lval vs[6];
vs[0] = var_52[2];
var_77 = wile_list_reverse(NULL, vs);
}
lval var_78;
{
lval vs[2];
vs[0] = var_76;
vs[1] = var_77;
var_78 = gen_list(2, vs, NULL);
}
var_54 = var_78;
}
return var_54;
}
// end of lambda fn_50

// (cholesky-decompose mat)
lval wile_cholesky_decompose(lptr* var_1, lptr var_2)
{
lptr var_51[0];
lval var_79;
var_79 = LVI_NIL();
lval var_80;
var_80 = LVI_NIL();
lval var_81;
lval var_82[6];
var_82[0] = var_2[0];
var_82[1] = var_79;
var_82[2] = var_80;
var_81 = fn_50(var_51, var_82);
return var_81;
}
// end of function wile_cholesky_decompose

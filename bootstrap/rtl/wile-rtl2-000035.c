// Generated by wile, the extremely stable scheming genius compiler

#include "wile-rtl1.h"
#include "wile-rtl2.h"

// declarations

extern lval var_argv;
extern lval var_cmd_name;
extern lval var_stdin;
extern lval var_stdout;
extern lval var_stderr;
extern lval var_pi;
extern lval var_euler_gamma;
extern lval var_show_sign;
extern lval var_int_base;
extern lval var_flt_base;
extern lval var_flt_precision;
#include "wile-rtl2.h"
static lval fn_5(lptr*, lptr, const char*);

// definitions

// @@@ lambda (x) @@@ bld-rtl-dir/wile-rtl2-000035.scm:14 @@@ fn_5 @@@
static lval fn_5(lptr* var_6, lptr var_7, const char* cloc)
{
return var_7[0];
}
// end of lambda fn_5

// @@@ promote/rat @@@ bld-rtl-dir/wile-rtl2-000035.scm:14 @@@ fn_9 @@@
static lval fn_9(lptr* var_10, lptr var_11, const char* cloc)
{
lval var_13;
if (var_11[0].vt == LV_INT) {
var_13 = LVI_RAT(var_11[0].v.iv, 1);
} else {
var_13 = var_11[0];
}
return var_13;
}
// end of prim fn_9

// @@@ promote/real @@@ bld-rtl-dir/wile-rtl2-000035.scm:14 @@@ fn_14 @@@
static lval fn_14(lptr* var_15, lptr var_16, const char* cloc)
{
lval var_18;
if (var_16[0].vt == LV_INT) {
var_18 = LVI_REAL((lisp_real_t) var_16[0].v.iv);
} else if (var_16[0].vt == LV_RAT) {
var_18 = LVI_REAL(LV_RAT2REAL(var_16[0]));
} else {
var_18 = var_16[0];
}
return var_18;
}
// end of prim fn_14

// @@@ min/i @@@ bld-rtl-dir/wile-rtl2-000035.scm:15 @@@ fn_22 @@@
static lval fn_22(lptr* var_23, lptr var_24, const char* cloc)
{
lval var_26;
var_26 = LVI_INT((var_24[0].v.iv < var_24[1].v.iv) ? var_24[0].v.iv : var_24[1].v.iv);
return var_26;
}
// end of prim fn_22

// @@@ min/q @@@ bld-rtl-dir/wile-rtl2-000035.scm:15 @@@ fn_27 @@@
static lval fn_27(lptr* var_28, lptr var_29, const char* cloc)
{
lval var_31;
if (var_29[0].v.irv.num * var_29[1].v.irv.den < var_29[1].v.irv.num * var_29[0].v.irv.den) {
var_31 = var_29[0];
} else {
var_31 = var_29[1];
}
return var_31;
}
// end of prim fn_27

// @@@ min/r @@@ bld-rtl-dir/wile-rtl2-000035.scm:15 @@@ fn_32 @@@
static lval fn_32(lptr* var_33, lptr var_34, const char* cloc)
{
lval var_36;
var_36 = LVI_REAL((var_34[0].v.rv < var_34[1].v.rv) ? var_34[0].v.rv : var_34[1].v.rv);
return var_36;
}
// end of prim fn_32

// @@@ max/i @@@ bld-rtl-dir/wile-rtl2-000035.scm:22 @@@ fn_57 @@@
static lval fn_57(lptr* var_58, lptr var_59, const char* cloc)
{
lval var_61;
var_61 = LVI_INT((var_59[0].v.iv > var_59[1].v.iv) ? var_59[0].v.iv : var_59[1].v.iv);
return var_61;
}
// end of prim fn_57

// @@@ number/type @@@ bld-rtl-dir/wile-rtl2-000035.scm:22 @@@ fn_63 @@@
static lval fn_63(lptr* var_64, lptr var_65, const char* cloc)
{
lval var_67;
switch (var_65[0].vt) {
case LV_INT:
var_67 = LVI_INT(0);
break;
case LV_RAT:
var_67 = LVI_INT(1);
break;
case LV_REAL:
var_67 = LVI_INT(2);
break;
case LV_CMPLX:
var_67 = LVI_INT(3);
break;
default:
var_67 = LVI_INT(4);
break;
}
return var_67;
}
// end of prim fn_63

// @@@ (min . vs) @@@ bld-rtl-dir/wile-rtl2-000035.scm:13 @@@ wile_min @@@
lval wile_min(lptr* var_1, lptr var_2, const char* cloc)
{
lval var_4;
MK_CLOS(var_6,0);
lval var_19;
{
lval var_20[3];
var_20[0] = LVI_PROC(fn_5,var_6,1);
var_20[1] = LVI_PROC(fn_9,NULL,1);
var_20[2] = LVI_PROC(fn_14,NULL,1);
var_19 = wile_gen_list(3, var_20, NULL);
}
var_4 = var_19;
lval var_21;
lval var_37;
{
lval var_38[3];
var_38[0] = LVI_PROC(fn_22,NULL,2);
var_38[1] = LVI_PROC(fn_27,NULL,2);
var_38[2] = LVI_PROC(fn_32,NULL,2);
var_37 = wile_gen_list(3, var_38, NULL);
}
var_21 = var_37;
lval var_39;
lval var_41;
var_41 = LVI_BOOL(var_2[0].vt == LV_NIL);
if (!LV_IS_FALSE(var_41)) {
lval var_42;
var_42 = LVI_REAL(1.00000000000000000000000000000000000e+00Q);
lval var_43;
var_43 = LVI_REAL(0.00000000000000000000000000000000000e+00Q);
lval var_44;
var_44 = LVI_REAL(var_42.v.rv / var_43.v.rv);
var_39 = var_44;
goto lbl_40;
}
lval var_45;
#ifdef WILE_DO_CHECK
if (var_2[0].vt != LV_PAIR) {
wile_exception("cdr", "bld-rtl-dir/wile-rtl2-000035.scm:17", "input is not a pair!");
}
#endif // WILE_DO_CHECK
var_45 = (var_2[0].v.pair.cdr ? *(var_2[0].v.pair.cdr) : LVI_NIL());
lval var_46;
var_46 = LVI_BOOL(var_45.vt == LV_NIL);
if (!LV_IS_FALSE(var_46)) {
lval var_47;
lval var_48;
#ifdef WILE_DO_CHECK
if (var_2[0].vt != LV_PAIR) {
wile_exception("car", "bld-rtl-dir/wile-rtl2-000035.scm:18", "input is not a pair!");
}
#endif // WILE_DO_CHECK
var_48 = (var_2[0].v.pair.car ? *(var_2[0].v.pair.car) : LVI_NIL());
lval var_49;
switch (var_48.vt) {
case LV_INT:
var_49 = LVI_INT(0);
break;
case LV_RAT:
var_49 = LVI_INT(1);
break;
case LV_REAL:
var_49 = LVI_INT(2);
break;
case LV_CMPLX:
var_49 = LVI_INT(3);
break;
default:
var_49 = LVI_INT(4);
break;
}
lval var_50;
var_50 = LVI_INT(3);
lval var_51;
switch (TYPE_COMBO(var_49.vt,var_50.vt)) {
case TYPE_COMBO(LV_INT,LV_INT):
var_51 = LVI_BOOL(var_49.v.iv < var_50.v.iv);
break;
case TYPE_COMBO(LV_INT,LV_RAT):
var_51 = LVI_BOOL(var_49.v.iv * var_50.v.irv.den < var_50.v.irv.num);
break;
case TYPE_COMBO(LV_INT,LV_REAL):
var_51 = LVI_BOOL(var_49.v.iv < var_50.v.rv);
break;
case TYPE_COMBO(LV_RAT,LV_INT):
var_51 = LVI_BOOL(var_49.v.irv.num < var_50.v.iv * var_49.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_RAT):
var_51 = LVI_BOOL(var_49.v.irv.num * var_50.v.irv.den < var_50.v.irv.num * var_49.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_REAL):
var_51 = LVI_BOOL(var_49.v.irv.num < var_50.v.rv * var_49.v.irv.den);
break;
case TYPE_COMBO(LV_REAL,LV_INT):
var_51 = LVI_BOOL(var_49.v.rv < var_50.v.iv);
break;
case TYPE_COMBO(LV_REAL,LV_RAT):
var_51 = LVI_BOOL(var_49.v.rv * var_50.v.irv.den < var_50.v.irv.num);
break;
case TYPE_COMBO(LV_REAL,LV_REAL):
var_51 = LVI_BOOL(var_49.v.rv < var_50.v.rv);
break;
default:
wile_exception("<", "bld-rtl-dir/wile-rtl2-000035.scm:18", "inputs are not real-valued numbers");
break;
}
if (LV_IS_FALSE(var_51)) {
lval var_52;
var_52 = LVI_STRING("min got a non-real argument");
lval var_53;
{
lval var_54[1];
var_54[0] = var_52;
var_53 = wile_gen_list(1, var_54, NULL);
}
if (var_53.vt == LV_PAIR && (var_53.v.pair.cdr == NULL || var_53.v.pair.cdr->vt == LV_NIL)) {
var_53 = (var_53.v.pair.car ? *(var_53.v.pair.car) : LVI_NIL());
}
cachalot->errval = new_lv(LV_NIL);
*(cachalot->errval) = var_53;
cachalot->whence = "bld-rtl-dir/wile-rtl2-000035.scm:20";
longjmp(cachalot->cenv, 1);
var_47 = var_53;
} else {
lval var_55;
#ifdef WILE_DO_CHECK
if (var_2[0].vt != LV_PAIR) {
wile_exception("car", "bld-rtl-dir/wile-rtl2-000035.scm:19", "input is not a pair!");
}
#endif // WILE_DO_CHECK
var_55 = (var_2[0].v.pair.car ? *(var_2[0].v.pair.car) : LVI_NIL());
var_47 = var_55;
}
var_39 = var_47;
goto lbl_40;
}
lval var_56;
lval var_62;
var_62 = LVI_INT(0);
lval var_68;
var_68 = LVI_NIL();
{
lval var_69[8];
var_69[0] = LVI_PROC(fn_63,NULL,1);
var_69[1] = var_2[0];
var_69[2] = var_68;
var_68 = wile_map(NULL, var_69, "bld-rtl-dir/wile-rtl2-000035.scm:22");
}
lval var_70;
{
lval var_71[8];
var_71[0] = LVI_PROC(fn_57,NULL,2);
var_71[1] = var_62;
var_71[2] = var_68;
var_70 = wile_foldl(NULL, var_71, "bld-rtl-dir/wile-rtl2-000035.scm:22");
}
var_56 = var_70;
lval var_72;
lval var_73;
var_73 = LVI_INT(3);
lval var_74;
switch (TYPE_COMBO(var_56.vt,var_73.vt)) {
case TYPE_COMBO(LV_INT,LV_INT):
var_74 = LVI_BOOL(var_56.v.iv < var_73.v.iv);
break;
case TYPE_COMBO(LV_INT,LV_RAT):
var_74 = LVI_BOOL(var_56.v.iv * var_73.v.irv.den < var_73.v.irv.num);
break;
case TYPE_COMBO(LV_INT,LV_REAL):
var_74 = LVI_BOOL(var_56.v.iv < var_73.v.rv);
break;
case TYPE_COMBO(LV_RAT,LV_INT):
var_74 = LVI_BOOL(var_56.v.irv.num < var_73.v.iv * var_56.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_RAT):
var_74 = LVI_BOOL(var_56.v.irv.num * var_73.v.irv.den < var_73.v.irv.num * var_56.v.irv.den);
break;
case TYPE_COMBO(LV_RAT,LV_REAL):
var_74 = LVI_BOOL(var_56.v.irv.num < var_73.v.rv * var_56.v.irv.den);
break;
case TYPE_COMBO(LV_REAL,LV_INT):
var_74 = LVI_BOOL(var_56.v.rv < var_73.v.iv);
break;
case TYPE_COMBO(LV_REAL,LV_RAT):
var_74 = LVI_BOOL(var_56.v.rv * var_73.v.irv.den < var_73.v.irv.num);
break;
case TYPE_COMBO(LV_REAL,LV_REAL):
var_74 = LVI_BOOL(var_56.v.rv < var_73.v.rv);
break;
default:
wile_exception("<", "bld-rtl-dir/wile-rtl2-000035.scm:23", "inputs are not real-valued numbers");
break;
}
if (LV_IS_FALSE(var_74)) {
lval var_75;
var_75 = LVI_STRING("min got a non-real argument");
lval var_76;
{
lval var_77[1];
var_77[0] = var_75;
var_76 = wile_gen_list(1, var_77, NULL);
}
if (var_76.vt == LV_PAIR && (var_76.v.pair.cdr == NULL || var_76.v.pair.cdr->vt == LV_NIL)) {
var_76 = (var_76.v.pair.car ? *(var_76.v.pair.car) : LVI_NIL());
}
cachalot->errval = new_lv(LV_NIL);
*(cachalot->errval) = var_76;
cachalot->whence = "bld-rtl-dir/wile-rtl2-000035.scm:25";
longjmp(cachalot->cenv, 1);
var_72 = var_76;
} else {
lval var_78;
{
lval var_79[8];
var_79[0] = var_21;
var_79[1] = var_56;
var_78 = wile_list_ref(NULL, var_79, "bld-rtl-dir/wile-rtl2-000035.scm:24");
}
lval var_80;
{
lval var_81[8];
var_81[0] = var_4;
var_81[1] = var_56;
var_80 = wile_list_ref(NULL, var_81, "bld-rtl-dir/wile-rtl2-000035.scm:24");
}
lval var_82;
var_82 = LVI_NIL();
{
lval var_83[8];
var_83[0] = var_80;
var_83[1] = var_2[0];
var_83[2] = var_82;
var_82 = wile_map(NULL, var_83, "bld-rtl-dir/wile-rtl2-000035.scm:24");
}
lval var_84;
{
lval var_85[8];
var_85[0] = var_78;
var_85[1] = var_82;
var_84 = wile_foldl1(NULL, var_85, "bld-rtl-dir/wile-rtl2-000035.scm:24");
}
var_72 = var_84;
}
var_39 = var_72;
lbl_40:;
return var_39;
}
// end of function wile_min

;;; The beginnings of an interpreter in wile - iwile? wilei? wili?
;;; This is, no surprise, still extremely fragile and very incomplete

(define (atom? val)
  (or (null? val)
      (boolean? val)
      (char? val)
      (string? val)
      (integer? val)
      (rational? val)
      (real? val)
      (complex? val)
      (file-port? val)
      (pipe-port? val)
      (socket-port? val)
      (string-port? val)
      (sqlite-port? val)
      (sqlite-statement? val)
      (vector? val)
      (bytevector? val)))

(define (special-form? val)
  (and (symbol? val)
       (or (symbol=? val 'quote)
	   (symbol=? val 'and)
	   (symbol=? val 'begin)
	   (symbol=? val 'case)
	   (symbol=? val 'cond)
	   (symbol=? val 'define)
	   (symbol=? val 'do)
	   (symbol=? val 'guard)
	   (symbol=? val 'if)
	   (symbol=? val 'lambda)
	   (symbol=? val 'let)
	   (symbol=? val 'let*)
	   (symbol=? val 'letrec)
	   (symbol=? val 'letrec*)
	   (symbol=? val 'or)
	   (symbol=? val 'set!))))

(define (symbol-lookup env sym)
  (let ((find (assv sym env)))
    (if find
	(cdr find)
	(begin
	  (fprintf stderr "error: symbol '%s' lookup failed!\n" sym)
	  #f))))

(define (eval-begin env expr)
  (if (null? expr)
      ()				;;; TODO: this could be an error too
      (let loop ((es expr))
	(let ((ev (eval-expr env (car es))))
	  (if (null? (cdr es))
	      ev
	      (loop (cdr es)))))))

(define (eval-if env exprs)
  (if (= 3 (list-length exprs))
      (let ((t (eval-expr env (car exprs))))
	(eval-expr env ((if t cadr caddr) exprs)))
      (begin
	(fprintf stderr "error: malformed 'if' expression %v\n" exprs)
	#f)))

(define (eval-expr env expr)
  (cond ((atom? expr) expr)
	((symbol? expr)
	 (symbol-lookup env expr))
	((pair? expr)
	 (cond ((special-form? (car expr))
		(case (car expr)
		  ((quote) (cadr expr))
		  ((begin) (eval-begin env (cdr expr)))
		  ((if) (eval-if env (cdr expr)))
		  (else 'not-quote-or-begin)))
	       (else
		(let ((vs (map (lambda (e) (eval-expr env e)) expr)))
		  (apply (car vs) (cdr vs))))))))

;;;	((promise? expr) 'promise)
;;;	((procedure? expr) 'procedure)
;;;	((continuation? expr) 'continuation)

(define top-env
  (list '(a . 1)
	'(b . 2)
	'(c . 3)
	'(d . 4)
	'(e . 5)
	'(f . 6)
	'(g . 7)
	'(h . 8)
	'(i . 9)
	'(j . #f)
	'(k . #t)
	`(+ . ,+)
	`(sqrt . ,sqrt)
	'(l . "foo")
	'(m . "bar")
	'(n . #(1 2 3))
	'(o . ())

	;;; the ones that are commented out can't be compiled just yet,
	;;; as they have multiple possible args -> ambiguous wrap

	;;; from here on, shit's real
	;;; aliases first
	`(creal . ,real-part)
	`(cimag . ,imag-part)
	`(last . ,list-last)
	`(make-rectangular . ,cmplx)
	`(phase . ,angle)
	`(complex-conjugate . ,cconj)
	`(conj . ,cconj)
	`(number? . ,complex?)
	`(char-lower-case? . ,char-lowercase?)
	`(char-upper-case? . ,char-uppercase?)
	`(list->string . ,char->string)
	`(magnitude . ,abs)
	`(modulo . ,floor-remainder)
	`(quotient . ,truncate-quotient)
	`(remainder . ,truncate-remainder)
	`(quot-rem . ,truncate/)
	`(directory-exists? . ,file-exists?)
	`(rename-directory . ,rename-file)
;;;	`(make-vector . ,vector-create)
;;;	`(make-string . ,string-create)
	`(vector-capacity . ,vector-length)
;;;	`(make-bytevector . ,bytevector-create)
;;;	`(substring . ,string-copy)
	`(read-all . ,parse-file)
	`(sqlite-close . ,close-port)
	`(agm . ,arithmetic-geometric-mean)

	;;; a bunch of functions
	;;; TODO: this is probably incomplete, check
	`(cons . ,cons)
	`(car . ,car)
	`(cdr . ,cdr)
	`(cxr . ,cxr)
	`(caar . ,caar)
	`(cadr . ,cadr)
	`(cdar . ,cdar)
	`(cddr . ,cddr)
	`(pair? . ,pair?)
	`(list . ,list)
	`(reverse . ,list-reverse)
	`(list-reverse . ,list-reverse)
	`(list? . ,list?)
	`(port? . ,port?)
	`(file-port? . ,file-port?)
	`(pipe-port? . ,pipe-port?)
	`(socket-port? . ,socket-port?)
	`(string-port? . ,string-port?)
	`(sqlite-port? . ,sqlite-port?)
	`(sqlite-statement? . ,sqlite-statement?)
;;;	`(flush-port . ,flush-port)
	`(open-temporary-file . ,open-temporary-file)
	`(close-port . ,close-port)
	`(create-link . ,create-link)
	`(create-symbolic-link . ,create-symbolic-link)
	`(eqv? . ,eqv?)
	`(vector? . ,vector?)
	`(promise? . ,promise?)
	`(continuation? . ,continuation?)
	`(get-parent-process-id . ,get-parent-process-id)
	`(get-user-id . ,get-user-id)
	`(set-user-id . ,set-user-id)
	`(get-effective-user-id . ,get-effective-user-id)
	`(set-effective-user-id . ,set-effective-user-id)
	`(get-group-id . ,get-group-id)
	`(set-group-id . ,set-group-id)
	`(get-effective-group-id . ,get-effective-group-id)
	`(set-effective-group-id . ,set-effective-group-id)
	`(get-session-id . ,get-session-id)
	`(set-session-id . ,set-session-id)
	`(epochtime . ,epochtime)
	`(gensym . ,gensym)
	`(run-command . ,run-command)
	`(run-read-command . ,run-read-command)
	`(run-write-command . ,run-write-command)
	`(fork-process . ,fork-process)
	`(get-current-directory . ,get-current-directory)
	`(set-current-directory . ,set-current-directory)
	`(get-file-position . ,get-file-position)
;;;	`(set-file-position . ,set-file-position)
	`(set-line-buffering! . ,set-line-buffering!)
	`(set-no-buffering! . ,set-no-buffering!)
	`(get-host-name . ,get-host-name)
	`(get-domain-name . ,get-domain-name)
	`(read-line . ,read-line)
;;;	`(read-char . ,read-char)
;;;	`(newline . ,newline)
;;;	`(write-1str . ,write-1str)
;;;	`(display . ,display)
	`(string->number . ,string->number)
	`(wile-build-info . ,wile-build-info)
	`(julian-day . ,julian-day)
	`(gregorian-date . ,gregorian-date)
	`(string-pad-left . ,string-pad-left)
	`(string-trim-left . ,string-trim-left)
	`(list-head . ,list-head)
	`(fromto . ,fromto)
	`(length . ,list-length)
	`(list-length . ,list-length)))

(define (finish status)
  (write-string "adios!\n")
  (exit status))

(let loop ()
  (write-string "repl> ")
  (flush-port stdout)
  (let ((line (read-line stdin)))
    (if (and line (not (string=? line "bye")))
	(guard (err (#t (fprintf stderr "caught exception %v\n" err)
			(loop)))
	       (printf "=> %v\n" (eval-expr top-env (car (parse-string line))))
	       (loop))
	(finish 0))))
